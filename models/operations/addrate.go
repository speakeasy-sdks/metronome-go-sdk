// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"github.com/speakeasy-sdks/metronome-go-sdk/internal/utils"
	"github.com/speakeasy-sdks/metronome-go-sdk/models/components"
	"time"
)

type RateType string

const (
	RateTypeFlatUpper         RateType = "FLAT"
	RateTypeFlatLower         RateType = "flat"
	RateTypePercentageUpper   RateType = "PERCENTAGE"
	RateTypePercentageLower   RateType = "percentage"
	RateTypeSubscriptionUpper RateType = "SUBSCRIPTION"
	RateTypeSubscriptionLower RateType = "subscription"
	RateTypeTieredUpper       RateType = "TIERED"
	RateTypeTieredLower       RateType = "tiered"
	RateTypeCustomUpper       RateType = "CUSTOM"
	RateTypeCustomLower       RateType = "custom"
)

func (e RateType) ToPointer() *RateType {
	return &e
}
func (e *RateType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "FLAT":
		fallthrough
	case "flat":
		fallthrough
	case "PERCENTAGE":
		fallthrough
	case "percentage":
		fallthrough
	case "SUBSCRIPTION":
		fallthrough
	case "subscription":
		fallthrough
	case "TIERED":
		fallthrough
	case "tiered":
		fallthrough
	case "CUSTOM":
		fallthrough
	case "custom":
		*e = RateType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RateType: %v", v)
	}
}

type Tiers struct {
	Size  *float64 `json:"size,omitempty"`
	Price float64  `json:"price"`
}

func (o *Tiers) GetSize() *float64 {
	if o == nil {
		return nil
	}
	return o.Size
}

func (o *Tiers) GetPrice() float64 {
	if o == nil {
		return 0.0
	}
	return o.Price
}

// AddRateRequestBody - Add a new rate
type AddRateRequestBody struct {
	// ID of the rate card to update
	RateCardID string `json:"rate_card_id"`
	// ID of the product to add a rate for
	ProductID string `json:"product_id"`
	// Optional. List of pricing group key value pairs which will be used to calculate the price.
	PricingGroupValues map[string]string `json:"pricing_group_values,omitempty"`
	// inclusive effective date
	StartingAt time.Time `json:"starting_at"`
	// exclusive end date
	EndingBefore *time.Time `json:"ending_before,omitempty"`
	Entitled     bool       `json:"entitled"`
	RateType     RateType   `json:"rate_type"`
	// Default price. For FLAT and SUBSCRIPTION rate_type, this must be >=0. For PERCENTAGE rate_type, this is a decimal fraction, e.g. use 0.1 for 10%; this must be >=0 and <=1.
	Price *float64 `json:"price,omitempty"`
	// "The Metronome ID of the credit type to associate with price, defaults to USD (cents) if not passed. Used by all rate_types except type PERCENTAGE. PERCENTAGE rates use the credit type of associated rates."
	CreditTypeID *string `json:"credit_type_id,omitempty"`
	// Default quantity. For SUBSCRIPTION rate_type, this must be >=0.
	Quantity *float64 `json:"quantity,omitempty"`
	// Default proration configuration. Only valid for SUBSCRIPTION rate_type.
	IsProrated *bool `json:"is_prorated,omitempty"`
	// Only set for PERCENTAGE rate_type. Defaults to false. If true, rate is computed using list prices rather than the standard rates for this product on the contract.
	UseListPrices *bool `json:"use_list_prices,omitempty"`
	// Only set for TIERED rate_type.
	Tiers []Tiers `json:"tiers,omitempty"`
	// Only set for CUSTOM rate_type. This field is interpreted by custom rate processors.
	CustomRate map[string]any `json:"custom_rate,omitempty"`
}

func (a AddRateRequestBody) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AddRateRequestBody) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *AddRateRequestBody) GetRateCardID() string {
	if o == nil {
		return ""
	}
	return o.RateCardID
}

func (o *AddRateRequestBody) GetProductID() string {
	if o == nil {
		return ""
	}
	return o.ProductID
}

func (o *AddRateRequestBody) GetPricingGroupValues() map[string]string {
	if o == nil {
		return nil
	}
	return o.PricingGroupValues
}

func (o *AddRateRequestBody) GetStartingAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.StartingAt
}

func (o *AddRateRequestBody) GetEndingBefore() *time.Time {
	if o == nil {
		return nil
	}
	return o.EndingBefore
}

func (o *AddRateRequestBody) GetEntitled() bool {
	if o == nil {
		return false
	}
	return o.Entitled
}

func (o *AddRateRequestBody) GetRateType() RateType {
	if o == nil {
		return RateType("")
	}
	return o.RateType
}

func (o *AddRateRequestBody) GetPrice() *float64 {
	if o == nil {
		return nil
	}
	return o.Price
}

func (o *AddRateRequestBody) GetCreditTypeID() *string {
	if o == nil {
		return nil
	}
	return o.CreditTypeID
}

func (o *AddRateRequestBody) GetQuantity() *float64 {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *AddRateRequestBody) GetIsProrated() *bool {
	if o == nil {
		return nil
	}
	return o.IsProrated
}

func (o *AddRateRequestBody) GetUseListPrices() *bool {
	if o == nil {
		return nil
	}
	return o.UseListPrices
}

func (o *AddRateRequestBody) GetTiers() []Tiers {
	if o == nil {
		return nil
	}
	return o.Tiers
}

func (o *AddRateRequestBody) GetCustomRate() map[string]any {
	if o == nil {
		return nil
	}
	return o.CustomRate
}

type AddRateRateType string

const (
	AddRateRateTypeFlatUpper         AddRateRateType = "FLAT"
	AddRateRateTypeFlatLower         AddRateRateType = "flat"
	AddRateRateTypePercentageUpper   AddRateRateType = "PERCENTAGE"
	AddRateRateTypePercentageLower   AddRateRateType = "percentage"
	AddRateRateTypeSubscriptionUpper AddRateRateType = "SUBSCRIPTION"
	AddRateRateTypeSubscriptionLower AddRateRateType = "subscription"
	AddRateRateTypeCustomUpper       AddRateRateType = "CUSTOM"
	AddRateRateTypeCustomLower       AddRateRateType = "custom"
	AddRateRateTypeTieredUpper       AddRateRateType = "TIERED"
	AddRateRateTypeTieredLower       AddRateRateType = "tiered"
)

func (e AddRateRateType) ToPointer() *AddRateRateType {
	return &e
}
func (e *AddRateRateType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "FLAT":
		fallthrough
	case "flat":
		fallthrough
	case "PERCENTAGE":
		fallthrough
	case "percentage":
		fallthrough
	case "SUBSCRIPTION":
		fallthrough
	case "subscription":
		fallthrough
	case "CUSTOM":
		fallthrough
	case "custom":
		fallthrough
	case "TIERED":
		fallthrough
	case "tiered":
		*e = AddRateRateType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AddRateRateType: %v", v)
	}
}

type AddRateTiers struct {
	Size  *float64 `json:"size,omitempty"`
	Price float64  `json:"price"`
}

func (o *AddRateTiers) GetSize() *float64 {
	if o == nil {
		return nil
	}
	return o.Size
}

func (o *AddRateTiers) GetPrice() float64 {
	if o == nil {
		return 0.0
	}
	return o.Price
}

type CreditType struct {
	Name string `json:"name"`
	ID   string `json:"id"`
}

func (o *CreditType) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *CreditType) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

type AddRateData struct {
	RateType AddRateRateType `json:"rate_type"`
	// Default price. For FLAT rate_type, this must be >=0. For PERCENTAGE rate_type, this is a decimal fraction, e.g. use 0.1 for 10%; this must be >=0 and <=1.
	Price *float64 `json:"price,omitempty"`
	// Only set for CUSTOM rate_type. This field is interpreted by custom rate processors.
	CustomRate map[string]any `json:"custom_rate,omitempty"`
	// Only set for PERCENTAGE rate_type. Defaults to false. If true, rate is computed using list prices rather than the standard rates for this product on the contract.
	UseListPrices *bool `json:"use_list_prices,omitempty"`
	// Default quantity. For SUBSCRIPTION rate_type, this must be >=0.
	Quantity *float64 `json:"quantity,omitempty"`
	// Default proration configuration. Only valid for SUBSCRIPTION rate_type.
	IsProrated *bool `json:"is_prorated,omitempty"`
	// Only set for TIERED rate_type.
	Tiers []AddRateTiers `json:"tiers,omitempty"`
	// if pricing groups are used, this will contain the values used to calculate the price
	PricingGroupValues map[string]string `json:"pricing_group_values,omitempty"`
	CreditType         *CreditType       `json:"credit_type,omitempty"`
}

func (o *AddRateData) GetRateType() AddRateRateType {
	if o == nil {
		return AddRateRateType("")
	}
	return o.RateType
}

func (o *AddRateData) GetPrice() *float64 {
	if o == nil {
		return nil
	}
	return o.Price
}

func (o *AddRateData) GetCustomRate() map[string]any {
	if o == nil {
		return nil
	}
	return o.CustomRate
}

func (o *AddRateData) GetUseListPrices() *bool {
	if o == nil {
		return nil
	}
	return o.UseListPrices
}

func (o *AddRateData) GetQuantity() *float64 {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *AddRateData) GetIsProrated() *bool {
	if o == nil {
		return nil
	}
	return o.IsProrated
}

func (o *AddRateData) GetTiers() []AddRateTiers {
	if o == nil {
		return nil
	}
	return o.Tiers
}

func (o *AddRateData) GetPricingGroupValues() map[string]string {
	if o == nil {
		return nil
	}
	return o.PricingGroupValues
}

func (o *AddRateData) GetCreditType() *CreditType {
	if o == nil {
		return nil
	}
	return o.CreditType
}

// AddRateResponseBody - Success
type AddRateResponseBody struct {
	Data AddRateData `json:"data"`
}

func (o *AddRateResponseBody) GetData() AddRateData {
	if o == nil {
		return AddRateData{}
	}
	return o.Data
}

type AddRateResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// Success
	Object *AddRateResponseBody
}

func (o *AddRateResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *AddRateResponse) GetObject() *AddRateResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
