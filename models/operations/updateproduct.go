// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"github.com/speakeasy-sdks/metronome-go-sdk/internal/utils"
	"github.com/speakeasy-sdks/metronome-go-sdk/models/components"
	"time"
)

// UpdateProductOperation - The operation to perform on the quantity
type UpdateProductOperation string

const (
	UpdateProductOperationMultiplyLower UpdateProductOperation = "multiply"
	UpdateProductOperationDivideLower   UpdateProductOperation = "divide"
	UpdateProductOperationMultiplyUpper UpdateProductOperation = "MULTIPLY"
	UpdateProductOperationDivideUpper   UpdateProductOperation = "DIVIDE"
)

func (e UpdateProductOperation) ToPointer() *UpdateProductOperation {
	return &e
}
func (e *UpdateProductOperation) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "multiply":
		fallthrough
	case "divide":
		fallthrough
	case "MULTIPLY":
		fallthrough
	case "DIVIDE":
		*e = UpdateProductOperation(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateProductOperation: %v", v)
	}
}

// UpdateProductQuantityConversion - Optional. Only valid for USAGE products. If provided, the quantity will be converted using the provided conversion factor and operation. For example, if the operation is "multiply" and the conversion factor is 100, then the quantity will be multiplied by 100. This can be used in cases where data is sent in one unit and priced in another.  For example, data could be sent in MB and priced in GB. In this case, the conversion factor would be 1024 and the operation would be "divide".
type UpdateProductQuantityConversion struct {
	// Optional name for this conversion.
	Name *string `json:"name,omitempty"`
	// The factor to multiply or divide the quantity by.
	ConversionFactor float64 `json:"conversion_factor"`
	// The operation to perform on the quantity
	Operation UpdateProductOperation `json:"operation"`
}

func (o *UpdateProductQuantityConversion) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *UpdateProductQuantityConversion) GetConversionFactor() float64 {
	if o == nil {
		return 0.0
	}
	return o.ConversionFactor
}

func (o *UpdateProductQuantityConversion) GetOperation() UpdateProductOperation {
	if o == nil {
		return UpdateProductOperation("")
	}
	return o.Operation
}

type UpdateProductRoundingMethod string

const (
	UpdateProductRoundingMethodRoundUpLower     UpdateProductRoundingMethod = "round_up"
	UpdateProductRoundingMethodRoundDownLower   UpdateProductRoundingMethod = "round_down"
	UpdateProductRoundingMethodRoundHalfUpLower UpdateProductRoundingMethod = "round_half_up"
	UpdateProductRoundingMethodRoundUpUpper     UpdateProductRoundingMethod = "ROUND_UP"
	UpdateProductRoundingMethodRoundDownUpper   UpdateProductRoundingMethod = "ROUND_DOWN"
	UpdateProductRoundingMethodRoundHalfUpUpper UpdateProductRoundingMethod = "ROUND_HALF_UP"
)

func (e UpdateProductRoundingMethod) ToPointer() *UpdateProductRoundingMethod {
	return &e
}
func (e *UpdateProductRoundingMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "round_up":
		fallthrough
	case "round_down":
		fallthrough
	case "round_half_up":
		fallthrough
	case "ROUND_UP":
		fallthrough
	case "ROUND_DOWN":
		fallthrough
	case "ROUND_HALF_UP":
		*e = UpdateProductRoundingMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateProductRoundingMethod: %v", v)
	}
}

// UpdateProductQuantityRounding - Optional. Only valid for USAGE products. If provided, the quantity will be rounded using the provided rounding method and decimal places. For example, if the method is "round up" and the decimal places is 0, then the quantity will be rounded up to the nearest integer.
type UpdateProductQuantityRounding struct {
	RoundingMethod UpdateProductRoundingMethod `json:"rounding_method"`
	DecimalPlaces  float64                     `json:"decimal_places"`
}

func (o *UpdateProductQuantityRounding) GetRoundingMethod() UpdateProductRoundingMethod {
	if o == nil {
		return UpdateProductRoundingMethod("")
	}
	return o.RoundingMethod
}

func (o *UpdateProductQuantityRounding) GetDecimalPlaces() float64 {
	if o == nil {
		return 0.0
	}
	return o.DecimalPlaces
}

// UpdateProductRequestBody - Update a product
type UpdateProductRequestBody struct {
	// ID of the product to update
	ProductID string `json:"product_id"`
	// displayed on invoices. If not provided, defaults to product's current name.
	Name *string `json:"name,omitempty"`
	// Timestamp representing when the update should go into effect. It must be on an hour boundary (e.g. 1:00, not 1:30).
	StartingAt time.Time `json:"starting_at"`
	// Defaults to product's current refundability status. This field's availability is dependent on your client's configuration.
	IsRefundable *bool `json:"is_refundable,omitempty"`
	// Beta feature only available for composite products. If true, products with $0 will not be included when computing composite usage. Defaults to false
	ExcludeFreeUsage *bool `json:"exclude_free_usage,omitempty"`
	// Available for USAGE products only. If not provided, defaults to product's current billable metric.
	BillableMetricID *string `json:"billable_metric_id,omitempty"`
	// If not provided, defaults to product's current netsuite_internal_item_id. This field's availability is dependent on your client's configuration.
	NetsuiteInternalItemID *string `json:"netsuite_internal_item_id,omitempty"`
	// Available for USAGE and COMPOSITE products only. If not provided, defaults to product's current netsuite_overage_item_id. This field's availability is dependent on your client's configuration.
	NetsuiteOverageItemID *string `json:"netsuite_overage_item_id,omitempty"`
	// Available for COMPOSITE products only. If not provided, defaults to product's current composite_product_ids.
	CompositeProductIds []string `json:"composite_product_ids,omitempty"`
	// Optional. Only valid for USAGE products. If provided, the quantity will be converted using the provided conversion factor and operation. For example, if the operation is "multiply" and the conversion factor is 100, then the quantity will be multiplied by 100. This can be used in cases where data is sent in one unit and priced in another.  For example, data could be sent in MB and priced in GB. In this case, the conversion factor would be 1024 and the operation would be "divide".
	QuantityConversion *UpdateProductQuantityConversion `json:"quantity_conversion,omitempty"`
	// Optional. Only valid for USAGE products. If provided, the quantity will be rounded using the provided rounding method and decimal places. For example, if the method is "round up" and the decimal places is 0, then the quantity will be rounded up to the nearest integer.
	QuantityRounding *UpdateProductQuantityRounding `json:"quantity_rounding,omitempty"`
	// If not provided, defaults to product's current tags
	Tags []string `json:"tags,omitempty"`
	// Available for COMPOSITE products only. If not provided, defaults to product's current composite_tags.
	CompositeTags []string `json:"composite_tags,omitempty"`
	// For USAGE products only. If set, pricing for this product will be determined for each pricing_group_key value, as opposed to the product as a whole.
	PricingGroupKey []string `json:"pricing_group_key,omitempty"`
	// For USAGE products only. Groups usage line items on invoices.
	PresentationGroupKey []string `json:"presentation_group_key,omitempty"`
}

func (u UpdateProductRequestBody) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UpdateProductRequestBody) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *UpdateProductRequestBody) GetProductID() string {
	if o == nil {
		return ""
	}
	return o.ProductID
}

func (o *UpdateProductRequestBody) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *UpdateProductRequestBody) GetStartingAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.StartingAt
}

func (o *UpdateProductRequestBody) GetIsRefundable() *bool {
	if o == nil {
		return nil
	}
	return o.IsRefundable
}

func (o *UpdateProductRequestBody) GetExcludeFreeUsage() *bool {
	if o == nil {
		return nil
	}
	return o.ExcludeFreeUsage
}

func (o *UpdateProductRequestBody) GetBillableMetricID() *string {
	if o == nil {
		return nil
	}
	return o.BillableMetricID
}

func (o *UpdateProductRequestBody) GetNetsuiteInternalItemID() *string {
	if o == nil {
		return nil
	}
	return o.NetsuiteInternalItemID
}

func (o *UpdateProductRequestBody) GetNetsuiteOverageItemID() *string {
	if o == nil {
		return nil
	}
	return o.NetsuiteOverageItemID
}

func (o *UpdateProductRequestBody) GetCompositeProductIds() []string {
	if o == nil {
		return nil
	}
	return o.CompositeProductIds
}

func (o *UpdateProductRequestBody) GetQuantityConversion() *UpdateProductQuantityConversion {
	if o == nil {
		return nil
	}
	return o.QuantityConversion
}

func (o *UpdateProductRequestBody) GetQuantityRounding() *UpdateProductQuantityRounding {
	if o == nil {
		return nil
	}
	return o.QuantityRounding
}

func (o *UpdateProductRequestBody) GetTags() []string {
	if o == nil {
		return nil
	}
	return o.Tags
}

func (o *UpdateProductRequestBody) GetCompositeTags() []string {
	if o == nil {
		return nil
	}
	return o.CompositeTags
}

func (o *UpdateProductRequestBody) GetPricingGroupKey() []string {
	if o == nil {
		return nil
	}
	return o.PricingGroupKey
}

func (o *UpdateProductRequestBody) GetPresentationGroupKey() []string {
	if o == nil {
		return nil
	}
	return o.PresentationGroupKey
}

type UpdateProductData struct {
	ID string `json:"id"`
}

func (o *UpdateProductData) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

// UpdateProductResponseBody - Success
type UpdateProductResponseBody struct {
	Data UpdateProductData `json:"data"`
}

func (o *UpdateProductResponseBody) GetData() UpdateProductData {
	if o == nil {
		return UpdateProductData{}
	}
	return o.Data
}

type UpdateProductResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// Success
	Object *UpdateProductResponseBody
}

func (o *UpdateProductResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *UpdateProductResponse) GetObject() *UpdateProductResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
