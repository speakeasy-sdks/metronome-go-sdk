// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"github.com/speakeasy-sdks/metronome-go-sdk/internal/utils"
	"github.com/speakeasy-sdks/metronome-go-sdk/models/components"
	"time"
)

type CreateContractType string

const (
	CreateContractTypePrepaidUpper  CreateContractType = "PREPAID"
	CreateContractTypePrepaidLower  CreateContractType = "prepaid"
	CreateContractTypePostpaidUpper CreateContractType = "POSTPAID"
	CreateContractTypePostpaidLower CreateContractType = "postpaid"
)

func (e CreateContractType) ToPointer() *CreateContractType {
	return &e
}
func (e *CreateContractType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "PREPAID":
		fallthrough
	case "prepaid":
		fallthrough
	case "POSTPAID":
		fallthrough
	case "postpaid":
		*e = CreateContractType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateContractType: %v", v)
	}
}

type ScheduleItems struct {
	Amount float64 `json:"amount"`
	// RFC 3339 timestamp (inclusive)
	StartingAt time.Time `json:"starting_at"`
	// RFC 3339 timestamp (exclusive)
	EndingBefore time.Time `json:"ending_before"`
}

func (s ScheduleItems) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *ScheduleItems) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *ScheduleItems) GetAmount() float64 {
	if o == nil {
		return 0.0
	}
	return o.Amount
}

func (o *ScheduleItems) GetStartingAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.StartingAt
}

func (o *ScheduleItems) GetEndingBefore() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.EndingBefore
}

// AccessSchedule - Required: Schedule for distributing the commit to the customer. For "POSTPAID" commits only one schedule item is allowed and amount must match invoice_schedule total.
type AccessSchedule struct {
	CreditTypeID  *string         `json:"credit_type_id,omitempty"`
	ScheduleItems []ScheduleItems `json:"schedule_items"`
}

func (o *AccessSchedule) GetCreditTypeID() *string {
	if o == nil {
		return nil
	}
	return o.CreditTypeID
}

func (o *AccessSchedule) GetScheduleItems() []ScheduleItems {
	if o == nil {
		return []ScheduleItems{}
	}
	return o.ScheduleItems
}

type CreateContractScheduleItems struct {
	// Unit price for the charge. Will be multiplied by quantity to determine the amount and must be specified with quantity. If specified amount cannot be provided.
	UnitPrice *float64 `json:"unit_price,omitempty"`
	// Quantity for the charge. Will be multiplied by unit_price to determine the amount and must be specified with unit_price. If specified amount cannot be provided.
	Quantity *float64 `json:"quantity,omitempty"`
	// Amount for the charge. Can be provided instead of unit_price and quantity. If amount is sent, the unit_price is assumed to be the amount and quantity is inferred to be 1.
	Amount *float64 `json:"amount,omitempty"`
	// timestamp of the scheduled event
	Timestamp time.Time `json:"timestamp"`
}

func (c CreateContractScheduleItems) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateContractScheduleItems) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *CreateContractScheduleItems) GetUnitPrice() *float64 {
	if o == nil {
		return nil
	}
	return o.UnitPrice
}

func (o *CreateContractScheduleItems) GetQuantity() *float64 {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *CreateContractScheduleItems) GetAmount() *float64 {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *CreateContractScheduleItems) GetTimestamp() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.Timestamp
}

type Frequency string

const (
	FrequencyMonthlyUpper    Frequency = "MONTHLY"
	FrequencyMonthlyLower    Frequency = "monthly"
	FrequencyQuarterlyUpper  Frequency = "QUARTERLY"
	FrequencyQuarterlyLower  Frequency = "quarterly"
	FrequencySemiAnnualUpper Frequency = "SEMI_ANNUAL"
	FrequencySemiAnnualLower Frequency = "semi_annual"
	FrequencyAnnualUpper     Frequency = "ANNUAL"
	FrequencyAnnualLower     Frequency = "annual"
)

func (e Frequency) ToPointer() *Frequency {
	return &e
}
func (e *Frequency) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MONTHLY":
		fallthrough
	case "monthly":
		fallthrough
	case "QUARTERLY":
		fallthrough
	case "quarterly":
		fallthrough
	case "SEMI_ANNUAL":
		fallthrough
	case "semi_annual":
		fallthrough
	case "ANNUAL":
		fallthrough
	case "annual":
		*e = Frequency(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Frequency: %v", v)
	}
}

type AmountDistribution string

const (
	AmountDistributionDividedUpper        AmountDistribution = "DIVIDED"
	AmountDistributionDividedLower        AmountDistribution = "divided"
	AmountDistributionDividedRoundedUpper AmountDistribution = "DIVIDED_ROUNDED"
	AmountDistributionDividedRoundedLower AmountDistribution = "divided_rounded"
	AmountDistributionEachUpper           AmountDistribution = "EACH"
	AmountDistributionEachLower           AmountDistribution = "each"
)

func (e AmountDistribution) ToPointer() *AmountDistribution {
	return &e
}
func (e *AmountDistribution) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DIVIDED":
		fallthrough
	case "divided":
		fallthrough
	case "DIVIDED_ROUNDED":
		fallthrough
	case "divided_rounded":
		fallthrough
	case "EACH":
		fallthrough
	case "each":
		*e = AmountDistribution(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AmountDistribution: %v", v)
	}
}

// RecurringSchedule - Enter the unit price and quantity for the charge or instead only send the amount. If amount is sent, the unit price is assumed to be the amount and quantity is inferred to be 1.
type RecurringSchedule struct {
	// RFC 3339 timestamp (inclusive).
	StartingAt time.Time `json:"starting_at"`
	// RFC 3339 timestamp (exclusive).
	EndingBefore time.Time `json:"ending_before"`
	Frequency    Frequency `json:"frequency"`
	// Unit price for the charge. Will be multiplied by quantity to determine the amount and must be specified with quantity. If specified amount cannot be provided.
	UnitPrice *float64 `json:"unit_price,omitempty"`
	// Quantity for the charge. Will be multiplied by unit_price to determine the amount and must be specified with unit_price. If specified amount cannot be provided.
	Quantity *float64 `json:"quantity,omitempty"`
	// Amount for the charge. Can be provided instead of unit_price and quantity. If amount is sent, the unit_price is assumed to be the amount and quantity is inferred to be 1.
	Amount             *float64           `json:"amount,omitempty"`
	AmountDistribution AmountDistribution `json:"amount_distribution"`
}

func (r RecurringSchedule) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RecurringSchedule) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *RecurringSchedule) GetStartingAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.StartingAt
}

func (o *RecurringSchedule) GetEndingBefore() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.EndingBefore
}

func (o *RecurringSchedule) GetFrequency() Frequency {
	if o == nil {
		return Frequency("")
	}
	return o.Frequency
}

func (o *RecurringSchedule) GetUnitPrice() *float64 {
	if o == nil {
		return nil
	}
	return o.UnitPrice
}

func (o *RecurringSchedule) GetQuantity() *float64 {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *RecurringSchedule) GetAmount() *float64 {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *RecurringSchedule) GetAmountDistribution() AmountDistribution {
	if o == nil {
		return AmountDistribution("")
	}
	return o.AmountDistribution
}

// InvoiceSchedule - Required for "POSTPAID" commits: the true up invoice will be generated at this time and only one schedule item is allowed; the total must match access_schedule amount. Optional for "PREPAID" commits: if not provided, this will be a "complimentary" commit with no invoice.
type InvoiceSchedule struct {
	// Defaults to USD if not passed. Only USD is supported at this time.
	CreditTypeID *string `json:"credit_type_id,omitempty"`
	// Either provide amount or provide both unit_price and quantity.
	ScheduleItems []CreateContractScheduleItems `json:"schedule_items,omitempty"`
	// Enter the unit price and quantity for the charge or instead only send the amount. If amount is sent, the unit price is assumed to be the amount and quantity is inferred to be 1.
	RecurringSchedule *RecurringSchedule `json:"recurring_schedule,omitempty"`
}

func (o *InvoiceSchedule) GetCreditTypeID() *string {
	if o == nil {
		return nil
	}
	return o.CreditTypeID
}

func (o *InvoiceSchedule) GetScheduleItems() []CreateContractScheduleItems {
	if o == nil {
		return nil
	}
	return o.ScheduleItems
}

func (o *InvoiceSchedule) GetRecurringSchedule() *RecurringSchedule {
	if o == nil {
		return nil
	}
	return o.RecurringSchedule
}

type Commits struct {
	Type CreateContractType `json:"type"`
	// displayed on invoices
	Name      *string `json:"name,omitempty"`
	ProductID string  `json:"product_id"`
	// Required: Schedule for distributing the commit to the customer. For "POSTPAID" commits only one schedule item is allowed and amount must match invoice_schedule total.
	AccessSchedule *AccessSchedule `json:"access_schedule,omitempty"`
	// Required for "POSTPAID" commits: the true up invoice will be generated at this time and only one schedule item is allowed; the total must match access_schedule amount. Optional for "PREPAID" commits: if not provided, this will be a "complimentary" commit with no invoice.
	InvoiceSchedule *InvoiceSchedule `json:"invoice_schedule,omitempty"`
	// (DEPRECATED) Use access_schedule and invoice_schedule instead.
	Amount *float64 `json:"amount,omitempty"`
	// Used only in UI/API. It is not exposed to end customers.
	Description *string `json:"description,omitempty"`
	// Fraction of unused segments that will be rolled over. Must be between 0 and 1.
	RolloverFraction *float64 `json:"rollover_fraction,omitempty"`
	// If multiple commits are applicable, the one with the lower priority will apply first.
	Priority *float64 `json:"priority,omitempty"`
	// Which products the commit applies to. If both applicable_product_ids and applicable_product_tags are not provided, the commit applies to all products.
	ApplicableProductIds []string `json:"applicable_product_ids,omitempty"`
	// Which tags the commit applies to. If both applicable_product_ids and applicable_product_tags are not provided, the commit applies to all products.
	ApplicableProductTags []string `json:"applicable_product_tags,omitempty"`
	// This field's availability is dependent on your client's configuration.
	NetsuiteSalesOrderID *string           `json:"netsuite_sales_order_id,omitempty"`
	CustomFields         map[string]string `json:"custom_fields,omitempty"`
}

func (o *Commits) GetType() CreateContractType {
	if o == nil {
		return CreateContractType("")
	}
	return o.Type
}

func (o *Commits) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Commits) GetProductID() string {
	if o == nil {
		return ""
	}
	return o.ProductID
}

func (o *Commits) GetAccessSchedule() *AccessSchedule {
	if o == nil {
		return nil
	}
	return o.AccessSchedule
}

func (o *Commits) GetInvoiceSchedule() *InvoiceSchedule {
	if o == nil {
		return nil
	}
	return o.InvoiceSchedule
}

func (o *Commits) GetAmount() *float64 {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *Commits) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *Commits) GetRolloverFraction() *float64 {
	if o == nil {
		return nil
	}
	return o.RolloverFraction
}

func (o *Commits) GetPriority() *float64 {
	if o == nil {
		return nil
	}
	return o.Priority
}

func (o *Commits) GetApplicableProductIds() []string {
	if o == nil {
		return nil
	}
	return o.ApplicableProductIds
}

func (o *Commits) GetApplicableProductTags() []string {
	if o == nil {
		return nil
	}
	return o.ApplicableProductTags
}

func (o *Commits) GetNetsuiteSalesOrderID() *string {
	if o == nil {
		return nil
	}
	return o.NetsuiteSalesOrderID
}

func (o *Commits) GetCustomFields() map[string]string {
	if o == nil {
		return nil
	}
	return o.CustomFields
}

type CreateContractContractsScheduleItems struct {
	Amount float64 `json:"amount"`
	// RFC 3339 timestamp (inclusive)
	StartingAt time.Time `json:"starting_at"`
	// RFC 3339 timestamp (exclusive)
	EndingBefore time.Time `json:"ending_before"`
}

func (c CreateContractContractsScheduleItems) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateContractContractsScheduleItems) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *CreateContractContractsScheduleItems) GetAmount() float64 {
	if o == nil {
		return 0.0
	}
	return o.Amount
}

func (o *CreateContractContractsScheduleItems) GetStartingAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.StartingAt
}

func (o *CreateContractContractsScheduleItems) GetEndingBefore() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.EndingBefore
}

// CreateContractAccessSchedule - Schedule for distributing the credit to the customer.
type CreateContractAccessSchedule struct {
	CreditTypeID  *string                                `json:"credit_type_id,omitempty"`
	ScheduleItems []CreateContractContractsScheduleItems `json:"schedule_items"`
}

func (o *CreateContractAccessSchedule) GetCreditTypeID() *string {
	if o == nil {
		return nil
	}
	return o.CreditTypeID
}

func (o *CreateContractAccessSchedule) GetScheduleItems() []CreateContractContractsScheduleItems {
	if o == nil {
		return []CreateContractContractsScheduleItems{}
	}
	return o.ScheduleItems
}

type Credits struct {
	// displayed on invoices
	Name      *string `json:"name,omitempty"`
	ProductID string  `json:"product_id"`
	// Schedule for distributing the credit to the customer.
	AccessSchedule CreateContractAccessSchedule `json:"access_schedule"`
	// Used only in UI/API. It is not exposed to end customers.
	Description *string `json:"description,omitempty"`
	// Which products the credit applies to. If both applicable_product_ids and applicable_product_tags are not provided, the credit applies to all products.
	ApplicableProductIds []string `json:"applicable_product_ids,omitempty"`
	// Which tags the credit applies to. If both applicable_product_ids and applicable_product_tags are not provided, the credit applies to all products.
	ApplicableProductTags []string `json:"applicable_product_tags,omitempty"`
	// This field's availability is dependent on your client's configuration.
	NetsuiteSalesOrderID *string `json:"netsuite_sales_order_id,omitempty"`
	// If multiple credits are applicable, the one with the lower priority will apply first.
	Priority     *float64          `json:"priority,omitempty"`
	CustomFields map[string]string `json:"custom_fields,omitempty"`
}

func (o *Credits) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Credits) GetProductID() string {
	if o == nil {
		return ""
	}
	return o.ProductID
}

func (o *Credits) GetAccessSchedule() CreateContractAccessSchedule {
	if o == nil {
		return CreateContractAccessSchedule{}
	}
	return o.AccessSchedule
}

func (o *Credits) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *Credits) GetApplicableProductIds() []string {
	if o == nil {
		return nil
	}
	return o.ApplicableProductIds
}

func (o *Credits) GetApplicableProductTags() []string {
	if o == nil {
		return nil
	}
	return o.ApplicableProductTags
}

func (o *Credits) GetNetsuiteSalesOrderID() *string {
	if o == nil {
		return nil
	}
	return o.NetsuiteSalesOrderID
}

func (o *Credits) GetPriority() *float64 {
	if o == nil {
		return nil
	}
	return o.Priority
}

func (o *Credits) GetCustomFields() map[string]string {
	if o == nil {
		return nil
	}
	return o.CustomFields
}

// MultiplierOverridePrioritization - Defaults to LOWEST_MULTIPLIER, which applies the greatest discount to list prices automatically. EXPLICIT prioritization requires specifying priorities for each multiplier; the one with the lowest priority value will be prioritized first. If tiered overrides are used, prioritization must be explicit.
type MultiplierOverridePrioritization string

const (
	MultiplierOverridePrioritizationLowestMultiplierUpper MultiplierOverridePrioritization = "LOWEST_MULTIPLIER"
	MultiplierOverridePrioritizationLowestMultiplierLower MultiplierOverridePrioritization = "lowest_multiplier"
	MultiplierOverridePrioritizationExplicitUpper         MultiplierOverridePrioritization = "EXPLICIT"
	MultiplierOverridePrioritizationExplicitLower         MultiplierOverridePrioritization = "explicit"
)

func (e MultiplierOverridePrioritization) ToPointer() *MultiplierOverridePrioritization {
	return &e
}
func (e *MultiplierOverridePrioritization) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "LOWEST_MULTIPLIER":
		fallthrough
	case "lowest_multiplier":
		fallthrough
	case "EXPLICIT":
		fallthrough
	case "explicit":
		*e = MultiplierOverridePrioritization(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MultiplierOverridePrioritization: %v", v)
	}
}

// CreateContractContractsType - Overwrites are prioritized over multipliers and tiered overrides.
type CreateContractContractsType string

const (
	CreateContractContractsTypeOverwriteUpper  CreateContractContractsType = "OVERWRITE"
	CreateContractContractsTypeOverwriteLower  CreateContractContractsType = "overwrite"
	CreateContractContractsTypeMultiplierUpper CreateContractContractsType = "MULTIPLIER"
	CreateContractContractsTypeMultiplierLower CreateContractContractsType = "multiplier"
	CreateContractContractsTypeTieredUpper     CreateContractContractsType = "TIERED"
	CreateContractContractsTypeTieredLower     CreateContractContractsType = "tiered"
)

func (e CreateContractContractsType) ToPointer() *CreateContractContractsType {
	return &e
}
func (e *CreateContractContractsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "OVERWRITE":
		fallthrough
	case "overwrite":
		fallthrough
	case "MULTIPLIER":
		fallthrough
	case "multiplier":
		fallthrough
	case "TIERED":
		fallthrough
	case "tiered":
		*e = CreateContractContractsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateContractContractsType: %v", v)
	}
}

type CreateContractRateType string

const (
	CreateContractRateTypeFlatUpper         CreateContractRateType = "FLAT"
	CreateContractRateTypeFlatLower         CreateContractRateType = "flat"
	CreateContractRateTypePercentageUpper   CreateContractRateType = "PERCENTAGE"
	CreateContractRateTypePercentageLower   CreateContractRateType = "percentage"
	CreateContractRateTypeSubscriptionUpper CreateContractRateType = "SUBSCRIPTION"
	CreateContractRateTypeSubscriptionLower CreateContractRateType = "subscription"
	CreateContractRateTypeTieredUpper       CreateContractRateType = "TIERED"
	CreateContractRateTypeTieredLower       CreateContractRateType = "tiered"
	CreateContractRateTypeCustomUpper       CreateContractRateType = "CUSTOM"
	CreateContractRateTypeCustomLower       CreateContractRateType = "custom"
)

func (e CreateContractRateType) ToPointer() *CreateContractRateType {
	return &e
}
func (e *CreateContractRateType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "FLAT":
		fallthrough
	case "flat":
		fallthrough
	case "PERCENTAGE":
		fallthrough
	case "percentage":
		fallthrough
	case "SUBSCRIPTION":
		fallthrough
	case "subscription":
		fallthrough
	case "TIERED":
		fallthrough
	case "tiered":
		fallthrough
	case "CUSTOM":
		fallthrough
	case "custom":
		*e = CreateContractRateType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateContractRateType: %v", v)
	}
}

type CreateContractTiers struct {
	Size  *float64 `json:"size,omitempty"`
	Price float64  `json:"price"`
}

func (o *CreateContractTiers) GetSize() *float64 {
	if o == nil {
		return nil
	}
	return o.Size
}

func (o *CreateContractTiers) GetPrice() float64 {
	if o == nil {
		return 0.0
	}
	return o.Price
}

// OverwriteRate - Required for OVERWRITE type.
type OverwriteRate struct {
	RateType CreateContractRateType `json:"rate_type"`
	// Default price. For FLAT rate_type, this must be >=0. For PERCENTAGE rate_type, this is a decimal fraction, e.g. use 0.1 for 10%; this must be >=0 and <=1.
	Price *float64 `json:"price,omitempty"`
	// Default quantity. For SUBSCRIPTION rate_type, this must be >=0.
	Quantity *float64 `json:"quantity,omitempty"`
	// Default proration configuration. Only valid for SUBSCRIPTION rate_type.
	IsProrated *bool `json:"is_prorated,omitempty"`
	// Only set for TIERED rate_type.
	Tiers []CreateContractTiers `json:"tiers,omitempty"`
	// Only set for CUSTOM rate_type. This field is interpreted by custom rate processors.
	CustomRate   map[string]any `json:"custom_rate,omitempty"`
	CreditTypeID *string        `json:"credit_type_id,omitempty"`
}

func (o *OverwriteRate) GetRateType() CreateContractRateType {
	if o == nil {
		return CreateContractRateType("")
	}
	return o.RateType
}

func (o *OverwriteRate) GetPrice() *float64 {
	if o == nil {
		return nil
	}
	return o.Price
}

func (o *OverwriteRate) GetQuantity() *float64 {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *OverwriteRate) GetIsProrated() *bool {
	if o == nil {
		return nil
	}
	return o.IsProrated
}

func (o *OverwriteRate) GetTiers() []CreateContractTiers {
	if o == nil {
		return nil
	}
	return o.Tiers
}

func (o *OverwriteRate) GetCustomRate() map[string]any {
	if o == nil {
		return nil
	}
	return o.CustomRate
}

func (o *OverwriteRate) GetCreditTypeID() *string {
	if o == nil {
		return nil
	}
	return o.CreditTypeID
}

type OverrideSpecifiers struct {
	// If provided, the override will only apply to the product with the specified ID.
	ProductID *string `json:"product_id,omitempty"`
	// If provided, the override will only apply to products with all the specified tags.
	ProductTags []string `json:"product_tags,omitempty"`
	// A map of pricing group names to values. The override will only apply to products with the specified pricing group values.
	PricingGroupValues map[string]string `json:"pricing_group_values,omitempty"`
	// A map of group names to values. The override will only apply to line items with the specified presentation group values. Can only be used for multiplier overrides.
	PresentationGroupValues map[string]string `json:"presentation_group_values,omitempty"`
}

func (o *OverrideSpecifiers) GetProductID() *string {
	if o == nil {
		return nil
	}
	return o.ProductID
}

func (o *OverrideSpecifiers) GetProductTags() []string {
	if o == nil {
		return nil
	}
	return o.ProductTags
}

func (o *OverrideSpecifiers) GetPricingGroupValues() map[string]string {
	if o == nil {
		return nil
	}
	return o.PricingGroupValues
}

func (o *OverrideSpecifiers) GetPresentationGroupValues() map[string]string {
	if o == nil {
		return nil
	}
	return o.PresentationGroupValues
}

type CreateContractContractsTiers struct {
	Size       *float64 `json:"size,omitempty"`
	Multiplier float64  `json:"multiplier"`
}

func (o *CreateContractContractsTiers) GetSize() *float64 {
	if o == nil {
		return nil
	}
	return o.Size
}

func (o *CreateContractContractsTiers) GetMultiplier() float64 {
	if o == nil {
		return 0.0
	}
	return o.Multiplier
}

type Overrides struct {
	// RFC 3339 timestamp indicating when the override will start applying (inclusive)
	StartingAt time.Time `json:"starting_at"`
	// RFC 3339 timestamp indicating when the override will stop applying (exclusive)
	EndingBefore *time.Time `json:"ending_before,omitempty"`
	Entitled     *bool      `json:"entitled,omitempty"`
	// Overwrites are prioritized over multipliers and tiered overrides.
	Type *CreateContractContractsType `json:"type,omitempty"`
	// Required for MULTIPLIER type. Must be >=0.
	Multiplier *float64 `json:"multiplier,omitempty"`
	// Required for EXPLICIT multiplier prioritization scheme and all TIERED overrides. Under EXPLICIT prioritization, overwrites are prioritized first, and then tiered and multiplier overrides are prioritized by their priority value (lowest first). Must be > 0.
	Priority *float64 `json:"priority,omitempty"`
	// Required for OVERWRITE type.
	OverwriteRate *OverwriteRate `json:"overwrite_rate,omitempty"`
	// ID of the product whose rate is being overridden
	ProductID *string `json:"product_id,omitempty"`
	// tags identifying products whose rates are being overridden
	ApplicableProductTags []string `json:"applicable_product_tags,omitempty"`
	// Cannot be used in conjunction with product_id or applicable_product_tags. If provided, the override will apply to all products with the specified specifiers.
	OverrideSpecifiers []OverrideSpecifiers `json:"override_specifiers,omitempty"`
	// Required for TIERED type. Must have at least one tier.
	Tiers []CreateContractContractsTiers `json:"tiers,omitempty"`
}

func (o Overrides) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *Overrides) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *Overrides) GetStartingAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.StartingAt
}

func (o *Overrides) GetEndingBefore() *time.Time {
	if o == nil {
		return nil
	}
	return o.EndingBefore
}

func (o *Overrides) GetEntitled() *bool {
	if o == nil {
		return nil
	}
	return o.Entitled
}

func (o *Overrides) GetType() *CreateContractContractsType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *Overrides) GetMultiplier() *float64 {
	if o == nil {
		return nil
	}
	return o.Multiplier
}

func (o *Overrides) GetPriority() *float64 {
	if o == nil {
		return nil
	}
	return o.Priority
}

func (o *Overrides) GetOverwriteRate() *OverwriteRate {
	if o == nil {
		return nil
	}
	return o.OverwriteRate
}

func (o *Overrides) GetProductID() *string {
	if o == nil {
		return nil
	}
	return o.ProductID
}

func (o *Overrides) GetApplicableProductTags() []string {
	if o == nil {
		return nil
	}
	return o.ApplicableProductTags
}

func (o *Overrides) GetOverrideSpecifiers() []OverrideSpecifiers {
	if o == nil {
		return nil
	}
	return o.OverrideSpecifiers
}

func (o *Overrides) GetTiers() []CreateContractContractsTiers {
	if o == nil {
		return nil
	}
	return o.Tiers
}

type CreateContractContractsRequestScheduleItems struct {
	// Unit price for the charge. Will be multiplied by quantity to determine the amount and must be specified with quantity. If specified amount cannot be provided.
	UnitPrice *float64 `json:"unit_price,omitempty"`
	// Quantity for the charge. Will be multiplied by unit_price to determine the amount and must be specified with unit_price. If specified amount cannot be provided.
	Quantity *float64 `json:"quantity,omitempty"`
	// Amount for the charge. Can be provided instead of unit_price and quantity. If amount is sent, the unit_price is assumed to be the amount and quantity is inferred to be 1.
	Amount *float64 `json:"amount,omitempty"`
	// timestamp of the scheduled event
	Timestamp time.Time `json:"timestamp"`
}

func (c CreateContractContractsRequestScheduleItems) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateContractContractsRequestScheduleItems) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *CreateContractContractsRequestScheduleItems) GetUnitPrice() *float64 {
	if o == nil {
		return nil
	}
	return o.UnitPrice
}

func (o *CreateContractContractsRequestScheduleItems) GetQuantity() *float64 {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *CreateContractContractsRequestScheduleItems) GetAmount() *float64 {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *CreateContractContractsRequestScheduleItems) GetTimestamp() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.Timestamp
}

type CreateContractFrequency string

const (
	CreateContractFrequencyMonthlyUpper    CreateContractFrequency = "MONTHLY"
	CreateContractFrequencyMonthlyLower    CreateContractFrequency = "monthly"
	CreateContractFrequencyQuarterlyUpper  CreateContractFrequency = "QUARTERLY"
	CreateContractFrequencyQuarterlyLower  CreateContractFrequency = "quarterly"
	CreateContractFrequencySemiAnnualUpper CreateContractFrequency = "SEMI_ANNUAL"
	CreateContractFrequencySemiAnnualLower CreateContractFrequency = "semi_annual"
	CreateContractFrequencyAnnualUpper     CreateContractFrequency = "ANNUAL"
	CreateContractFrequencyAnnualLower     CreateContractFrequency = "annual"
)

func (e CreateContractFrequency) ToPointer() *CreateContractFrequency {
	return &e
}
func (e *CreateContractFrequency) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MONTHLY":
		fallthrough
	case "monthly":
		fallthrough
	case "QUARTERLY":
		fallthrough
	case "quarterly":
		fallthrough
	case "SEMI_ANNUAL":
		fallthrough
	case "semi_annual":
		fallthrough
	case "ANNUAL":
		fallthrough
	case "annual":
		*e = CreateContractFrequency(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateContractFrequency: %v", v)
	}
}

type CreateContractAmountDistribution string

const (
	CreateContractAmountDistributionDividedUpper        CreateContractAmountDistribution = "DIVIDED"
	CreateContractAmountDistributionDividedLower        CreateContractAmountDistribution = "divided"
	CreateContractAmountDistributionDividedRoundedUpper CreateContractAmountDistribution = "DIVIDED_ROUNDED"
	CreateContractAmountDistributionDividedRoundedLower CreateContractAmountDistribution = "divided_rounded"
	CreateContractAmountDistributionEachUpper           CreateContractAmountDistribution = "EACH"
	CreateContractAmountDistributionEachLower           CreateContractAmountDistribution = "each"
)

func (e CreateContractAmountDistribution) ToPointer() *CreateContractAmountDistribution {
	return &e
}
func (e *CreateContractAmountDistribution) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DIVIDED":
		fallthrough
	case "divided":
		fallthrough
	case "DIVIDED_ROUNDED":
		fallthrough
	case "divided_rounded":
		fallthrough
	case "EACH":
		fallthrough
	case "each":
		*e = CreateContractAmountDistribution(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateContractAmountDistribution: %v", v)
	}
}

// CreateContractRecurringSchedule - Enter the unit price and quantity for the charge or instead only send the amount. If amount is sent, the unit price is assumed to be the amount and quantity is inferred to be 1.
type CreateContractRecurringSchedule struct {
	// RFC 3339 timestamp (inclusive).
	StartingAt time.Time `json:"starting_at"`
	// RFC 3339 timestamp (exclusive).
	EndingBefore time.Time               `json:"ending_before"`
	Frequency    CreateContractFrequency `json:"frequency"`
	// Unit price for the charge. Will be multiplied by quantity to determine the amount and must be specified with quantity. If specified amount cannot be provided.
	UnitPrice *float64 `json:"unit_price,omitempty"`
	// Quantity for the charge. Will be multiplied by unit_price to determine the amount and must be specified with unit_price. If specified amount cannot be provided.
	Quantity *float64 `json:"quantity,omitempty"`
	// Amount for the charge. Can be provided instead of unit_price and quantity. If amount is sent, the unit_price is assumed to be the amount and quantity is inferred to be 1.
	Amount             *float64                         `json:"amount,omitempty"`
	AmountDistribution CreateContractAmountDistribution `json:"amount_distribution"`
}

func (c CreateContractRecurringSchedule) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateContractRecurringSchedule) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *CreateContractRecurringSchedule) GetStartingAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.StartingAt
}

func (o *CreateContractRecurringSchedule) GetEndingBefore() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.EndingBefore
}

func (o *CreateContractRecurringSchedule) GetFrequency() CreateContractFrequency {
	if o == nil {
		return CreateContractFrequency("")
	}
	return o.Frequency
}

func (o *CreateContractRecurringSchedule) GetUnitPrice() *float64 {
	if o == nil {
		return nil
	}
	return o.UnitPrice
}

func (o *CreateContractRecurringSchedule) GetQuantity() *float64 {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *CreateContractRecurringSchedule) GetAmount() *float64 {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *CreateContractRecurringSchedule) GetAmountDistribution() CreateContractAmountDistribution {
	if o == nil {
		return CreateContractAmountDistribution("")
	}
	return o.AmountDistribution
}

// Schedule - Must provide either schedule_items or recurring_schedule.
type Schedule struct {
	// Defaults to USD if not passed. Only USD is supported at this time.
	CreditTypeID *string `json:"credit_type_id,omitempty"`
	// Either provide amount or provide both unit_price and quantity.
	ScheduleItems []CreateContractContractsRequestScheduleItems `json:"schedule_items,omitempty"`
	// Enter the unit price and quantity for the charge or instead only send the amount. If amount is sent, the unit price is assumed to be the amount and quantity is inferred to be 1.
	RecurringSchedule *CreateContractRecurringSchedule `json:"recurring_schedule,omitempty"`
}

func (o *Schedule) GetCreditTypeID() *string {
	if o == nil {
		return nil
	}
	return o.CreditTypeID
}

func (o *Schedule) GetScheduleItems() []CreateContractContractsRequestScheduleItems {
	if o == nil {
		return nil
	}
	return o.ScheduleItems
}

func (o *Schedule) GetRecurringSchedule() *CreateContractRecurringSchedule {
	if o == nil {
		return nil
	}
	return o.RecurringSchedule
}

type Discounts struct {
	ProductID string `json:"product_id"`
	// displayed on invoices
	Name *string `json:"name,omitempty"`
	// Must provide either schedule_items or recurring_schedule.
	Schedule Schedule `json:"schedule"`
	// This field's availability is dependent on your client's configuration.
	NetsuiteSalesOrderID *string `json:"netsuite_sales_order_id,omitempty"`
}

func (o *Discounts) GetProductID() string {
	if o == nil {
		return ""
	}
	return o.ProductID
}

func (o *Discounts) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Discounts) GetSchedule() Schedule {
	if o == nil {
		return Schedule{}
	}
	return o.Schedule
}

func (o *Discounts) GetNetsuiteSalesOrderID() *string {
	if o == nil {
		return nil
	}
	return o.NetsuiteSalesOrderID
}

type ProfessionalServices struct {
	Description *string `json:"description,omitempty"`
	ProductID   string  `json:"product_id"`
	// This field's availability is dependent on your client's configuration.
	NetsuiteSalesOrderID *string `json:"netsuite_sales_order_id,omitempty"`
	// Unit price for the charge. Will be multiplied by quantity to determine the amount and must be specified.
	UnitPrice float64 `json:"unit_price"`
	// Quantity for the charge. Will be multiplied by unit_price to determine the amount.
	Quantity float64 `json:"quantity"`
	// Maximum amount for the term.
	MaxAmount    float64           `json:"max_amount"`
	CustomFields map[string]string `json:"custom_fields,omitempty"`
}

func (o *ProfessionalServices) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *ProfessionalServices) GetProductID() string {
	if o == nil {
		return ""
	}
	return o.ProductID
}

func (o *ProfessionalServices) GetNetsuiteSalesOrderID() *string {
	if o == nil {
		return nil
	}
	return o.NetsuiteSalesOrderID
}

func (o *ProfessionalServices) GetUnitPrice() float64 {
	if o == nil {
		return 0.0
	}
	return o.UnitPrice
}

func (o *ProfessionalServices) GetQuantity() float64 {
	if o == nil {
		return 0.0
	}
	return o.Quantity
}

func (o *ProfessionalServices) GetMaxAmount() float64 {
	if o == nil {
		return 0.0
	}
	return o.MaxAmount
}

func (o *ProfessionalServices) GetCustomFields() map[string]string {
	if o == nil {
		return nil
	}
	return o.CustomFields
}

type ResellerType string

const (
	ResellerTypeAws           ResellerType = "AWS"
	ResellerTypeAwsProService ResellerType = "AWS_PRO_SERVICE"
	ResellerTypeGcp           ResellerType = "GCP"
	ResellerTypeGcpProService ResellerType = "GCP_PRO_SERVICE"
)

func (e ResellerType) ToPointer() *ResellerType {
	return &e
}
func (e *ResellerType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "AWS":
		fallthrough
	case "AWS_PRO_SERVICE":
		fallthrough
	case "GCP":
		fallthrough
	case "GCP_PRO_SERVICE":
		*e = ResellerType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ResellerType: %v", v)
	}
}

type AwsOptions struct {
	AwsAccountNumber    *string `json:"aws_account_number,omitempty"`
	AwsPayerReferenceID *string `json:"aws_payer_reference_id,omitempty"`
	AwsOfferID          *string `json:"aws_offer_id,omitempty"`
}

func (o *AwsOptions) GetAwsAccountNumber() *string {
	if o == nil {
		return nil
	}
	return o.AwsAccountNumber
}

func (o *AwsOptions) GetAwsPayerReferenceID() *string {
	if o == nil {
		return nil
	}
	return o.AwsPayerReferenceID
}

func (o *AwsOptions) GetAwsOfferID() *string {
	if o == nil {
		return nil
	}
	return o.AwsOfferID
}

type GcpOptions struct {
	GcpAccountID *string `json:"gcp_account_id,omitempty"`
	GcpOfferID   *string `json:"gcp_offer_id,omitempty"`
}

func (o *GcpOptions) GetGcpAccountID() *string {
	if o == nil {
		return nil
	}
	return o.GcpAccountID
}

func (o *GcpOptions) GetGcpOfferID() *string {
	if o == nil {
		return nil
	}
	return o.GcpOfferID
}

type ResellerRoyalties struct {
	ResellerType       ResellerType `json:"reseller_type"`
	Fraction           float64      `json:"fraction"`
	NetsuiteResellerID string       `json:"netsuite_reseller_id"`
	// Must provide at least one of applicable_product_ids or applicable_product_tags.
	ApplicableProductIds []string `json:"applicable_product_ids,omitempty"`
	// Must provide at least one of applicable_product_ids or applicable_product_tags.
	ApplicableProductTags []string    `json:"applicable_product_tags,omitempty"`
	StartingAt            time.Time   `json:"starting_at"`
	EndingBefore          *time.Time  `json:"ending_before,omitempty"`
	ResellerContractValue *float64    `json:"reseller_contract_value,omitempty"`
	AwsOptions            *AwsOptions `json:"aws_options,omitempty"`
	GcpOptions            *GcpOptions `json:"gcp_options,omitempty"`
}

func (r ResellerRoyalties) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *ResellerRoyalties) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *ResellerRoyalties) GetResellerType() ResellerType {
	if o == nil {
		return ResellerType("")
	}
	return o.ResellerType
}

func (o *ResellerRoyalties) GetFraction() float64 {
	if o == nil {
		return 0.0
	}
	return o.Fraction
}

func (o *ResellerRoyalties) GetNetsuiteResellerID() string {
	if o == nil {
		return ""
	}
	return o.NetsuiteResellerID
}

func (o *ResellerRoyalties) GetApplicableProductIds() []string {
	if o == nil {
		return nil
	}
	return o.ApplicableProductIds
}

func (o *ResellerRoyalties) GetApplicableProductTags() []string {
	if o == nil {
		return nil
	}
	return o.ApplicableProductTags
}

func (o *ResellerRoyalties) GetStartingAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.StartingAt
}

func (o *ResellerRoyalties) GetEndingBefore() *time.Time {
	if o == nil {
		return nil
	}
	return o.EndingBefore
}

func (o *ResellerRoyalties) GetResellerContractValue() *float64 {
	if o == nil {
		return nil
	}
	return o.ResellerContractValue
}

func (o *ResellerRoyalties) GetAwsOptions() *AwsOptions {
	if o == nil {
		return nil
	}
	return o.AwsOptions
}

func (o *ResellerRoyalties) GetGcpOptions() *GcpOptions {
	if o == nil {
		return nil
	}
	return o.GcpOptions
}

type CreateContractContractsRequestRequestBodyScheduleItems struct {
	// Unit price for the charge. Will be multiplied by quantity to determine the amount and must be specified with quantity. If specified amount cannot be provided.
	UnitPrice *float64 `json:"unit_price,omitempty"`
	// Quantity for the charge. Will be multiplied by unit_price to determine the amount and must be specified with unit_price. If specified amount cannot be provided.
	Quantity *float64 `json:"quantity,omitempty"`
	// Amount for the charge. Can be provided instead of unit_price and quantity. If amount is sent, the unit_price is assumed to be the amount and quantity is inferred to be 1.
	Amount *float64 `json:"amount,omitempty"`
	// timestamp of the scheduled event
	Timestamp time.Time `json:"timestamp"`
}

func (c CreateContractContractsRequestRequestBodyScheduleItems) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateContractContractsRequestRequestBodyScheduleItems) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *CreateContractContractsRequestRequestBodyScheduleItems) GetUnitPrice() *float64 {
	if o == nil {
		return nil
	}
	return o.UnitPrice
}

func (o *CreateContractContractsRequestRequestBodyScheduleItems) GetQuantity() *float64 {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *CreateContractContractsRequestRequestBodyScheduleItems) GetAmount() *float64 {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *CreateContractContractsRequestRequestBodyScheduleItems) GetTimestamp() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.Timestamp
}

type CreateContractContractsFrequency string

const (
	CreateContractContractsFrequencyMonthlyUpper    CreateContractContractsFrequency = "MONTHLY"
	CreateContractContractsFrequencyMonthlyLower    CreateContractContractsFrequency = "monthly"
	CreateContractContractsFrequencyQuarterlyUpper  CreateContractContractsFrequency = "QUARTERLY"
	CreateContractContractsFrequencyQuarterlyLower  CreateContractContractsFrequency = "quarterly"
	CreateContractContractsFrequencySemiAnnualUpper CreateContractContractsFrequency = "SEMI_ANNUAL"
	CreateContractContractsFrequencySemiAnnualLower CreateContractContractsFrequency = "semi_annual"
	CreateContractContractsFrequencyAnnualUpper     CreateContractContractsFrequency = "ANNUAL"
	CreateContractContractsFrequencyAnnualLower     CreateContractContractsFrequency = "annual"
)

func (e CreateContractContractsFrequency) ToPointer() *CreateContractContractsFrequency {
	return &e
}
func (e *CreateContractContractsFrequency) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MONTHLY":
		fallthrough
	case "monthly":
		fallthrough
	case "QUARTERLY":
		fallthrough
	case "quarterly":
		fallthrough
	case "SEMI_ANNUAL":
		fallthrough
	case "semi_annual":
		fallthrough
	case "ANNUAL":
		fallthrough
	case "annual":
		*e = CreateContractContractsFrequency(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateContractContractsFrequency: %v", v)
	}
}

type CreateContractContractsAmountDistribution string

const (
	CreateContractContractsAmountDistributionDividedUpper        CreateContractContractsAmountDistribution = "DIVIDED"
	CreateContractContractsAmountDistributionDividedLower        CreateContractContractsAmountDistribution = "divided"
	CreateContractContractsAmountDistributionDividedRoundedUpper CreateContractContractsAmountDistribution = "DIVIDED_ROUNDED"
	CreateContractContractsAmountDistributionDividedRoundedLower CreateContractContractsAmountDistribution = "divided_rounded"
	CreateContractContractsAmountDistributionEachUpper           CreateContractContractsAmountDistribution = "EACH"
	CreateContractContractsAmountDistributionEachLower           CreateContractContractsAmountDistribution = "each"
)

func (e CreateContractContractsAmountDistribution) ToPointer() *CreateContractContractsAmountDistribution {
	return &e
}
func (e *CreateContractContractsAmountDistribution) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DIVIDED":
		fallthrough
	case "divided":
		fallthrough
	case "DIVIDED_ROUNDED":
		fallthrough
	case "divided_rounded":
		fallthrough
	case "EACH":
		fallthrough
	case "each":
		*e = CreateContractContractsAmountDistribution(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateContractContractsAmountDistribution: %v", v)
	}
}

// CreateContractContractsRecurringSchedule - Enter the unit price and quantity for the charge or instead only send the amount. If amount is sent, the unit price is assumed to be the amount and quantity is inferred to be 1.
type CreateContractContractsRecurringSchedule struct {
	// RFC 3339 timestamp (inclusive).
	StartingAt time.Time `json:"starting_at"`
	// RFC 3339 timestamp (exclusive).
	EndingBefore time.Time                        `json:"ending_before"`
	Frequency    CreateContractContractsFrequency `json:"frequency"`
	// Unit price for the charge. Will be multiplied by quantity to determine the amount and must be specified with quantity. If specified amount cannot be provided.
	UnitPrice *float64 `json:"unit_price,omitempty"`
	// Quantity for the charge. Will be multiplied by unit_price to determine the amount and must be specified with unit_price. If specified amount cannot be provided.
	Quantity *float64 `json:"quantity,omitempty"`
	// Amount for the charge. Can be provided instead of unit_price and quantity. If amount is sent, the unit_price is assumed to be the amount and quantity is inferred to be 1.
	Amount             *float64                                  `json:"amount,omitempty"`
	AmountDistribution CreateContractContractsAmountDistribution `json:"amount_distribution"`
}

func (c CreateContractContractsRecurringSchedule) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateContractContractsRecurringSchedule) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *CreateContractContractsRecurringSchedule) GetStartingAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.StartingAt
}

func (o *CreateContractContractsRecurringSchedule) GetEndingBefore() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.EndingBefore
}

func (o *CreateContractContractsRecurringSchedule) GetFrequency() CreateContractContractsFrequency {
	if o == nil {
		return CreateContractContractsFrequency("")
	}
	return o.Frequency
}

func (o *CreateContractContractsRecurringSchedule) GetUnitPrice() *float64 {
	if o == nil {
		return nil
	}
	return o.UnitPrice
}

func (o *CreateContractContractsRecurringSchedule) GetQuantity() *float64 {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *CreateContractContractsRecurringSchedule) GetAmount() *float64 {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *CreateContractContractsRecurringSchedule) GetAmountDistribution() CreateContractContractsAmountDistribution {
	if o == nil {
		return CreateContractContractsAmountDistribution("")
	}
	return o.AmountDistribution
}

// CreateContractSchedule - Must provide either schedule_items or recurring_schedule.
type CreateContractSchedule struct {
	// Defaults to USD if not passed. Only USD is supported at this time.
	CreditTypeID *string `json:"credit_type_id,omitempty"`
	// Either provide amount or provide both unit_price and quantity.
	ScheduleItems []CreateContractContractsRequestRequestBodyScheduleItems `json:"schedule_items,omitempty"`
	// Enter the unit price and quantity for the charge or instead only send the amount. If amount is sent, the unit price is assumed to be the amount and quantity is inferred to be 1.
	RecurringSchedule *CreateContractContractsRecurringSchedule `json:"recurring_schedule,omitempty"`
}

func (o *CreateContractSchedule) GetCreditTypeID() *string {
	if o == nil {
		return nil
	}
	return o.CreditTypeID
}

func (o *CreateContractSchedule) GetScheduleItems() []CreateContractContractsRequestRequestBodyScheduleItems {
	if o == nil {
		return nil
	}
	return o.ScheduleItems
}

func (o *CreateContractSchedule) GetRecurringSchedule() *CreateContractContractsRecurringSchedule {
	if o == nil {
		return nil
	}
	return o.RecurringSchedule
}

type ScheduledCharges struct {
	ProductID string `json:"product_id"`
	// displayed on invoices
	Name *string `json:"name,omitempty"`
	// Must provide either schedule_items or recurring_schedule.
	Schedule CreateContractSchedule `json:"schedule"`
	// This field's availability is dependent on your client's configuration.
	NetsuiteSalesOrderID *string `json:"netsuite_sales_order_id,omitempty"`
}

func (o *ScheduledCharges) GetProductID() string {
	if o == nil {
		return ""
	}
	return o.ProductID
}

func (o *ScheduledCharges) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *ScheduledCharges) GetSchedule() CreateContractSchedule {
	if o == nil {
		return CreateContractSchedule{}
	}
	return o.Schedule
}

func (o *ScheduledCharges) GetNetsuiteSalesOrderID() *string {
	if o == nil {
		return nil
	}
	return o.NetsuiteSalesOrderID
}

// CreateContractContractsRequestType - This field's available values may vary based on your client's configuration.
type CreateContractContractsRequestType string

const (
	CreateContractContractsRequestTypeSupersedeUpper CreateContractContractsRequestType = "SUPERSEDE"
	CreateContractContractsRequestTypeRenewalUpper   CreateContractContractsRequestType = "RENEWAL"
	CreateContractContractsRequestTypeSupersedeLower CreateContractContractsRequestType = "supersede"
	CreateContractContractsRequestTypeRenewalLower   CreateContractContractsRequestType = "renewal"
)

func (e CreateContractContractsRequestType) ToPointer() *CreateContractContractsRequestType {
	return &e
}
func (e *CreateContractContractsRequestType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SUPERSEDE":
		fallthrough
	case "RENEWAL":
		fallthrough
	case "supersede":
		fallthrough
	case "renewal":
		*e = CreateContractContractsRequestType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateContractContractsRequestType: %v", v)
	}
}

// Trueup - Controls whether future trueup invoices are billed or removed. Default behavior is AS_IS if not specified.
type Trueup string

const (
	TrueupRemoveLower Trueup = "remove"
	TrueupAsIsLower   Trueup = "as_is"
	TrueupRemoveUpper Trueup = "REMOVE"
	TrueupAsIsUpper   Trueup = "AS_IS"
)

func (e Trueup) ToPointer() *Trueup {
	return &e
}
func (e *Trueup) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "remove":
		fallthrough
	case "as_is":
		fallthrough
	case "REMOVE":
		fallthrough
	case "AS_IS":
		*e = Trueup(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Trueup: %v", v)
	}
}

type FutureInvoiceBehavior struct {
	// Controls whether future trueup invoices are billed or removed. Default behavior is AS_IS if not specified.
	Trueup *Trueup `json:"trueup,omitempty"`
}

func (o *FutureInvoiceBehavior) GetTrueup() *Trueup {
	if o == nil {
		return nil
	}
	return o.Trueup
}

type Transition struct {
	// This field's available values may vary based on your client's configuration.
	Type                  CreateContractContractsRequestType `json:"type"`
	FromContractID        string                             `json:"from_contract_id"`
	FutureInvoiceBehavior *FutureInvoiceBehavior             `json:"future_invoice_behavior,omitempty"`
}

func (o *Transition) GetType() CreateContractContractsRequestType {
	if o == nil {
		return CreateContractContractsRequestType("")
	}
	return o.Type
}

func (o *Transition) GetFromContractID() string {
	if o == nil {
		return ""
	}
	return o.FromContractID
}

func (o *Transition) GetFutureInvoiceBehavior() *FutureInvoiceBehavior {
	if o == nil {
		return nil
	}
	return o.FutureInvoiceBehavior
}

type UsageFilter struct {
	GroupKey    string     `json:"group_key"`
	GroupValues []string   `json:"group_values"`
	StartingAt  *time.Time `json:"starting_at,omitempty"`
}

func (u UsageFilter) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UsageFilter) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *UsageFilter) GetGroupKey() string {
	if o == nil {
		return ""
	}
	return o.GroupKey
}

func (o *UsageFilter) GetGroupValues() []string {
	if o == nil {
		return []string{}
	}
	return o.GroupValues
}

func (o *UsageFilter) GetStartingAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.StartingAt
}

type CreateContractContractsRequestFrequency string

const (
	CreateContractContractsRequestFrequencyMonthlyUpper   CreateContractContractsRequestFrequency = "MONTHLY"
	CreateContractContractsRequestFrequencyMonthlyLower   CreateContractContractsRequestFrequency = "monthly"
	CreateContractContractsRequestFrequencyQuarterlyUpper CreateContractContractsRequestFrequency = "QUARTERLY"
	CreateContractContractsRequestFrequencyQuarterlyLower CreateContractContractsRequestFrequency = "quarterly"
)

func (e CreateContractContractsRequestFrequency) ToPointer() *CreateContractContractsRequestFrequency {
	return &e
}
func (e *CreateContractContractsRequestFrequency) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MONTHLY":
		fallthrough
	case "monthly":
		fallthrough
	case "QUARTERLY":
		fallthrough
	case "quarterly":
		*e = CreateContractContractsRequestFrequency(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateContractContractsRequestFrequency: %v", v)
	}
}

// Day - If not provided, defaults to the first day of the month.
type Day string

const (
	DayFirstOfMonthUpper  Day = "FIRST_OF_MONTH"
	DayFirstOfMonthLower  Day = "first_of_month"
	DayContractStartUpper Day = "CONTRACT_START"
	DayContractStartLower Day = "contract_start"
)

func (e Day) ToPointer() *Day {
	return &e
}
func (e *Day) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "FIRST_OF_MONTH":
		fallthrough
	case "first_of_month":
		fallthrough
	case "CONTRACT_START":
		fallthrough
	case "contract_start":
		*e = Day(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Day: %v", v)
	}
}

type UsageStatementSchedule struct {
	Frequency CreateContractContractsRequestFrequency `json:"frequency"`
	// If not provided, defaults to the first day of the month.
	Day *Day `json:"day,omitempty"`
	// The date Metronome should start generating usage invoices. If unspecified, contract start date will be used. This is useful to set if you want to import historical invoices via our 'Create Historical Invoices' API rather than having Metronome automatically generate them.
	InvoiceGenerationStartingAt *time.Time `json:"invoice_generation_starting_at,omitempty"`
}

func (u UsageStatementSchedule) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UsageStatementSchedule) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *UsageStatementSchedule) GetFrequency() CreateContractContractsRequestFrequency {
	if o == nil {
		return CreateContractContractsRequestFrequency("")
	}
	return o.Frequency
}

func (o *UsageStatementSchedule) GetDay() *Day {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *UsageStatementSchedule) GetInvoiceGenerationStartingAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.InvoiceGenerationStartingAt
}

type BillingProvider string

const (
	BillingProviderAwsMarketplace   BillingProvider = "aws_marketplace"
	BillingProviderAzureMarketplace BillingProvider = "azure_marketplace"
	BillingProviderGcpMarketplace   BillingProvider = "gcp_marketplace"
	BillingProviderStripe           BillingProvider = "stripe"
	BillingProviderNetsuite         BillingProvider = "netsuite"
)

func (e BillingProvider) ToPointer() *BillingProvider {
	return &e
}
func (e *BillingProvider) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "aws_marketplace":
		fallthrough
	case "azure_marketplace":
		fallthrough
	case "gcp_marketplace":
		fallthrough
	case "stripe":
		fallthrough
	case "netsuite":
		*e = BillingProvider(v)
		return nil
	default:
		return fmt.Errorf("invalid value for BillingProvider: %v", v)
	}
}

type DeliveryMethod string

const (
	DeliveryMethodDirectToBillingProvider DeliveryMethod = "direct_to_billing_provider"
	DeliveryMethodAwsSqs                  DeliveryMethod = "aws_sqs"
	DeliveryMethodTackle                  DeliveryMethod = "tackle"
	DeliveryMethodAwsSns                  DeliveryMethod = "aws_sns"
)

func (e DeliveryMethod) ToPointer() *DeliveryMethod {
	return &e
}
func (e *DeliveryMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "direct_to_billing_provider":
		fallthrough
	case "aws_sqs":
		fallthrough
	case "tackle":
		fallthrough
	case "aws_sns":
		*e = DeliveryMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DeliveryMethod: %v", v)
	}
}

// BillingProviderConfiguration - This field's availability is dependent on your client's configuration.
type BillingProviderConfiguration struct {
	// The Metronome ID of the billing provider configuration
	BillingProviderConfigurationID *string          `json:"billing_provider_configuration_id,omitempty"`
	BillingProvider                *BillingProvider `json:"billing_provider,omitempty"`
	DeliveryMethod                 *DeliveryMethod  `json:"delivery_method,omitempty"`
}

func (o *BillingProviderConfiguration) GetBillingProviderConfigurationID() *string {
	if o == nil {
		return nil
	}
	return o.BillingProviderConfigurationID
}

func (o *BillingProviderConfiguration) GetBillingProvider() *BillingProvider {
	if o == nil {
		return nil
	}
	return o.BillingProvider
}

func (o *BillingProviderConfiguration) GetDeliveryMethod() *DeliveryMethod {
	if o == nil {
		return nil
	}
	return o.DeliveryMethod
}

// CreateContractRequestBody - Create a new contract
type CreateContractRequestBody struct {
	CustomerID string  `json:"customer_id"`
	Name       *string `json:"name,omitempty"`
	// Prevents the creation of duplicates. If a request to create a record is made with a previously used uniqueness key, a new record will not be created and the request will fail with a 409 error.
	UniquenessKey *string `json:"uniqueness_key,omitempty"`
	// This field's availability is dependent on your client's configuration.
	NetsuiteSalesOrderID *string `json:"netsuite_sales_order_id,omitempty"`
	// This field's availability is dependent on your client's configuration.
	SalesforceOpportunityID *string  `json:"salesforce_opportunity_id,omitempty"`
	NetPaymentTermsDays     *float64 `json:"net_payment_terms_days,omitempty"`
	RateCardID              *string  `json:"rate_card_id,omitempty"`
	// Selects the rate card linked to the specified alias as of the contract's start date.
	RateCardAlias *string `json:"rate_card_alias,omitempty"`
	// This field's availability is dependent on your client's configuration.
	TotalContractValue *float64 `json:"total_contract_value,omitempty"`
	// inclusive contract start time
	StartingAt time.Time `json:"starting_at"`
	// exclusive contract end time
	EndingBefore *time.Time `json:"ending_before,omitempty"`
	Commits      []Commits  `json:"commits,omitempty"`
	Credits      []Credits  `json:"credits,omitempty"`
	// Defaults to LOWEST_MULTIPLIER, which applies the greatest discount to list prices automatically. EXPLICIT prioritization requires specifying priorities for each multiplier; the one with the lowest priority value will be prioritized first. If tiered overrides are used, prioritization must be explicit.
	MultiplierOverridePrioritization *MultiplierOverridePrioritization `json:"multiplier_override_prioritization,omitempty"`
	Overrides                        []Overrides                       `json:"overrides,omitempty"`
	// This field's availability is dependent on your client's configuration.
	Discounts []Discounts `json:"discounts,omitempty"`
	// This field's availability is dependent on your client's configuration.
	ProfessionalServices []ProfessionalServices `json:"professional_services,omitempty"`
	// This field's availability is dependent on your client's configuration.
	ResellerRoyalties      []ResellerRoyalties     `json:"reseller_royalties,omitempty"`
	ScheduledCharges       []ScheduledCharges      `json:"scheduled_charges,omitempty"`
	Transition             *Transition             `json:"transition,omitempty"`
	UsageFilter            *UsageFilter            `json:"usage_filter,omitempty"`
	UsageStatementSchedule *UsageStatementSchedule `json:"usage_statement_schedule,omitempty"`
	CustomFields           map[string]string       `json:"custom_fields,omitempty"`
	// This field's availability is dependent on your client's configuration.
	BillingProviderConfiguration *BillingProviderConfiguration `json:"billing_provider_configuration,omitempty"`
}

func (c CreateContractRequestBody) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateContractRequestBody) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *CreateContractRequestBody) GetCustomerID() string {
	if o == nil {
		return ""
	}
	return o.CustomerID
}

func (o *CreateContractRequestBody) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *CreateContractRequestBody) GetUniquenessKey() *string {
	if o == nil {
		return nil
	}
	return o.UniquenessKey
}

func (o *CreateContractRequestBody) GetNetsuiteSalesOrderID() *string {
	if o == nil {
		return nil
	}
	return o.NetsuiteSalesOrderID
}

func (o *CreateContractRequestBody) GetSalesforceOpportunityID() *string {
	if o == nil {
		return nil
	}
	return o.SalesforceOpportunityID
}

func (o *CreateContractRequestBody) GetNetPaymentTermsDays() *float64 {
	if o == nil {
		return nil
	}
	return o.NetPaymentTermsDays
}

func (o *CreateContractRequestBody) GetRateCardID() *string {
	if o == nil {
		return nil
	}
	return o.RateCardID
}

func (o *CreateContractRequestBody) GetRateCardAlias() *string {
	if o == nil {
		return nil
	}
	return o.RateCardAlias
}

func (o *CreateContractRequestBody) GetTotalContractValue() *float64 {
	if o == nil {
		return nil
	}
	return o.TotalContractValue
}

func (o *CreateContractRequestBody) GetStartingAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.StartingAt
}

func (o *CreateContractRequestBody) GetEndingBefore() *time.Time {
	if o == nil {
		return nil
	}
	return o.EndingBefore
}

func (o *CreateContractRequestBody) GetCommits() []Commits {
	if o == nil {
		return nil
	}
	return o.Commits
}

func (o *CreateContractRequestBody) GetCredits() []Credits {
	if o == nil {
		return nil
	}
	return o.Credits
}

func (o *CreateContractRequestBody) GetMultiplierOverridePrioritization() *MultiplierOverridePrioritization {
	if o == nil {
		return nil
	}
	return o.MultiplierOverridePrioritization
}

func (o *CreateContractRequestBody) GetOverrides() []Overrides {
	if o == nil {
		return nil
	}
	return o.Overrides
}

func (o *CreateContractRequestBody) GetDiscounts() []Discounts {
	if o == nil {
		return nil
	}
	return o.Discounts
}

func (o *CreateContractRequestBody) GetProfessionalServices() []ProfessionalServices {
	if o == nil {
		return nil
	}
	return o.ProfessionalServices
}

func (o *CreateContractRequestBody) GetResellerRoyalties() []ResellerRoyalties {
	if o == nil {
		return nil
	}
	return o.ResellerRoyalties
}

func (o *CreateContractRequestBody) GetScheduledCharges() []ScheduledCharges {
	if o == nil {
		return nil
	}
	return o.ScheduledCharges
}

func (o *CreateContractRequestBody) GetTransition() *Transition {
	if o == nil {
		return nil
	}
	return o.Transition
}

func (o *CreateContractRequestBody) GetUsageFilter() *UsageFilter {
	if o == nil {
		return nil
	}
	return o.UsageFilter
}

func (o *CreateContractRequestBody) GetUsageStatementSchedule() *UsageStatementSchedule {
	if o == nil {
		return nil
	}
	return o.UsageStatementSchedule
}

func (o *CreateContractRequestBody) GetCustomFields() map[string]string {
	if o == nil {
		return nil
	}
	return o.CustomFields
}

func (o *CreateContractRequestBody) GetBillingProviderConfiguration() *BillingProviderConfiguration {
	if o == nil {
		return nil
	}
	return o.BillingProviderConfiguration
}

type CreateContractData struct {
	ID string `json:"id"`
}

func (o *CreateContractData) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

// CreateContractResponseBody - Success
type CreateContractResponseBody struct {
	Data CreateContractData `json:"data"`
}

func (o *CreateContractResponseBody) GetData() CreateContractData {
	if o == nil {
		return CreateContractData{}
	}
	return o.Data
}

type CreateContractResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// Success
	Object *CreateContractResponseBody
}

func (o *CreateContractResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *CreateContractResponse) GetObject() *CreateContractResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
