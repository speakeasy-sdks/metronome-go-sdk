// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"github.com/Metronome-Industries/metronome-go-sdk/internal/utils"
	"github.com/Metronome-Industries/metronome-go-sdk/models/components"
	"time"
)

type AmendContractType string

const (
	AmendContractTypePrepaidUpper  AmendContractType = "PREPAID"
	AmendContractTypePrepaidLower  AmendContractType = "prepaid"
	AmendContractTypePostpaidUpper AmendContractType = "POSTPAID"
	AmendContractTypePostpaidLower AmendContractType = "postpaid"
)

func (e AmendContractType) ToPointer() *AmendContractType {
	return &e
}
func (e *AmendContractType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "PREPAID":
		fallthrough
	case "prepaid":
		fallthrough
	case "POSTPAID":
		fallthrough
	case "postpaid":
		*e = AmendContractType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AmendContractType: %v", v)
	}
}

type AmendContractScheduleItems struct {
	Amount float64 `json:"amount"`
	// RFC 3339 timestamp (inclusive)
	StartingAt time.Time `json:"starting_at"`
	// RFC 3339 timestamp (exclusive)
	EndingBefore time.Time `json:"ending_before"`
}

func (a AmendContractScheduleItems) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AmendContractScheduleItems) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *AmendContractScheduleItems) GetAmount() float64 {
	if o == nil {
		return 0.0
	}
	return o.Amount
}

func (o *AmendContractScheduleItems) GetStartingAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.StartingAt
}

func (o *AmendContractScheduleItems) GetEndingBefore() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.EndingBefore
}

// AmendContractAccessSchedule - Required: Schedule for distributing the commit to the customer. For "POSTPAID" commits only one schedule item is allowed and amount must match invoice_schedule total.
type AmendContractAccessSchedule struct {
	CreditTypeID  *string                      `json:"credit_type_id,omitempty"`
	ScheduleItems []AmendContractScheduleItems `json:"schedule_items"`
}

func (o *AmendContractAccessSchedule) GetCreditTypeID() *string {
	if o == nil {
		return nil
	}
	return o.CreditTypeID
}

func (o *AmendContractAccessSchedule) GetScheduleItems() []AmendContractScheduleItems {
	if o == nil {
		return []AmendContractScheduleItems{}
	}
	return o.ScheduleItems
}

type AmendContractContractsScheduleItems struct {
	// Unit price for the charge. Will be multiplied by quantity to determine the amount and must be specified with quantity. If specified amount cannot be provided.
	UnitPrice *float64 `json:"unit_price,omitempty"`
	// Quantity for the charge. Will be multiplied by unit_price to determine the amount and must be specified with unit_price. If specified amount cannot be provided.
	Quantity *float64 `json:"quantity,omitempty"`
	// Amount for the charge. Can be provided instead of unit_price and quantity. If amount is sent, the unit_price is assumed to be the amount and quantity is inferred to be 1.
	Amount *float64 `json:"amount,omitempty"`
	// timestamp of the scheduled event
	Timestamp time.Time `json:"timestamp"`
}

func (a AmendContractContractsScheduleItems) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AmendContractContractsScheduleItems) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *AmendContractContractsScheduleItems) GetUnitPrice() *float64 {
	if o == nil {
		return nil
	}
	return o.UnitPrice
}

func (o *AmendContractContractsScheduleItems) GetQuantity() *float64 {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *AmendContractContractsScheduleItems) GetAmount() *float64 {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *AmendContractContractsScheduleItems) GetTimestamp() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.Timestamp
}

type AmendContractFrequency string

const (
	AmendContractFrequencyMonthlyUpper    AmendContractFrequency = "MONTHLY"
	AmendContractFrequencyMonthlyLower    AmendContractFrequency = "monthly"
	AmendContractFrequencyQuarterlyUpper  AmendContractFrequency = "QUARTERLY"
	AmendContractFrequencyQuarterlyLower  AmendContractFrequency = "quarterly"
	AmendContractFrequencySemiAnnualUpper AmendContractFrequency = "SEMI_ANNUAL"
	AmendContractFrequencySemiAnnualLower AmendContractFrequency = "semi_annual"
	AmendContractFrequencyAnnualUpper     AmendContractFrequency = "ANNUAL"
	AmendContractFrequencyAnnualLower     AmendContractFrequency = "annual"
)

func (e AmendContractFrequency) ToPointer() *AmendContractFrequency {
	return &e
}
func (e *AmendContractFrequency) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MONTHLY":
		fallthrough
	case "monthly":
		fallthrough
	case "QUARTERLY":
		fallthrough
	case "quarterly":
		fallthrough
	case "SEMI_ANNUAL":
		fallthrough
	case "semi_annual":
		fallthrough
	case "ANNUAL":
		fallthrough
	case "annual":
		*e = AmendContractFrequency(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AmendContractFrequency: %v", v)
	}
}

type AmendContractAmountDistribution string

const (
	AmendContractAmountDistributionDividedUpper        AmendContractAmountDistribution = "DIVIDED"
	AmendContractAmountDistributionDividedLower        AmendContractAmountDistribution = "divided"
	AmendContractAmountDistributionDividedRoundedUpper AmendContractAmountDistribution = "DIVIDED_ROUNDED"
	AmendContractAmountDistributionDividedRoundedLower AmendContractAmountDistribution = "divided_rounded"
	AmendContractAmountDistributionEachUpper           AmendContractAmountDistribution = "EACH"
	AmendContractAmountDistributionEachLower           AmendContractAmountDistribution = "each"
)

func (e AmendContractAmountDistribution) ToPointer() *AmendContractAmountDistribution {
	return &e
}
func (e *AmendContractAmountDistribution) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DIVIDED":
		fallthrough
	case "divided":
		fallthrough
	case "DIVIDED_ROUNDED":
		fallthrough
	case "divided_rounded":
		fallthrough
	case "EACH":
		fallthrough
	case "each":
		*e = AmendContractAmountDistribution(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AmendContractAmountDistribution: %v", v)
	}
}

// AmendContractRecurringSchedule - Enter the unit price and quantity for the charge or instead only send the amount. If amount is sent, the unit price is assumed to be the amount and quantity is inferred to be 1.
type AmendContractRecurringSchedule struct {
	// RFC 3339 timestamp (inclusive).
	StartingAt time.Time `json:"starting_at"`
	// RFC 3339 timestamp (exclusive).
	EndingBefore time.Time              `json:"ending_before"`
	Frequency    AmendContractFrequency `json:"frequency"`
	// Unit price for the charge. Will be multiplied by quantity to determine the amount and must be specified with quantity. If specified amount cannot be provided.
	UnitPrice *float64 `json:"unit_price,omitempty"`
	// Quantity for the charge. Will be multiplied by unit_price to determine the amount and must be specified with unit_price. If specified amount cannot be provided.
	Quantity *float64 `json:"quantity,omitempty"`
	// Amount for the charge. Can be provided instead of unit_price and quantity. If amount is sent, the unit_price is assumed to be the amount and quantity is inferred to be 1.
	Amount             *float64                        `json:"amount,omitempty"`
	AmountDistribution AmendContractAmountDistribution `json:"amount_distribution"`
}

func (a AmendContractRecurringSchedule) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AmendContractRecurringSchedule) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *AmendContractRecurringSchedule) GetStartingAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.StartingAt
}

func (o *AmendContractRecurringSchedule) GetEndingBefore() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.EndingBefore
}

func (o *AmendContractRecurringSchedule) GetFrequency() AmendContractFrequency {
	if o == nil {
		return AmendContractFrequency("")
	}
	return o.Frequency
}

func (o *AmendContractRecurringSchedule) GetUnitPrice() *float64 {
	if o == nil {
		return nil
	}
	return o.UnitPrice
}

func (o *AmendContractRecurringSchedule) GetQuantity() *float64 {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *AmendContractRecurringSchedule) GetAmount() *float64 {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *AmendContractRecurringSchedule) GetAmountDistribution() AmendContractAmountDistribution {
	if o == nil {
		return AmendContractAmountDistribution("")
	}
	return o.AmountDistribution
}

// AmendContractInvoiceSchedule - Required for "POSTPAID" commits: the true up invoice will be generated at this time and only one schedule item is allowed; the total must match access_schedule amount. Optional for "PREPAID" commits: if not provided, this will be a "complimentary" commit with no invoice.
type AmendContractInvoiceSchedule struct {
	// Defaults to USD if not passed. Only USD is supported at this time.
	CreditTypeID *string `json:"credit_type_id,omitempty"`
	// Either provide amount or provide both unit_price and quantity.
	ScheduleItems []AmendContractContractsScheduleItems `json:"schedule_items,omitempty"`
	// Enter the unit price and quantity for the charge or instead only send the amount. If amount is sent, the unit price is assumed to be the amount and quantity is inferred to be 1.
	RecurringSchedule *AmendContractRecurringSchedule `json:"recurring_schedule,omitempty"`
}

func (o *AmendContractInvoiceSchedule) GetCreditTypeID() *string {
	if o == nil {
		return nil
	}
	return o.CreditTypeID
}

func (o *AmendContractInvoiceSchedule) GetScheduleItems() []AmendContractContractsScheduleItems {
	if o == nil {
		return nil
	}
	return o.ScheduleItems
}

func (o *AmendContractInvoiceSchedule) GetRecurringSchedule() *AmendContractRecurringSchedule {
	if o == nil {
		return nil
	}
	return o.RecurringSchedule
}

type AmendContractCommits struct {
	Type AmendContractType `json:"type"`
	// displayed on invoices
	Name      *string `json:"name,omitempty"`
	ProductID string  `json:"product_id"`
	// Required: Schedule for distributing the commit to the customer. For "POSTPAID" commits only one schedule item is allowed and amount must match invoice_schedule total.
	AccessSchedule *AmendContractAccessSchedule `json:"access_schedule,omitempty"`
	// Required for "POSTPAID" commits: the true up invoice will be generated at this time and only one schedule item is allowed; the total must match access_schedule amount. Optional for "PREPAID" commits: if not provided, this will be a "complimentary" commit with no invoice.
	InvoiceSchedule *AmendContractInvoiceSchedule `json:"invoice_schedule,omitempty"`
	// (DEPRECATED) Use access_schedule and invoice_schedule instead.
	Amount *float64 `json:"amount,omitempty"`
	// Used only in UI/API. It is not exposed to end customers.
	Description *string `json:"description,omitempty"`
	// Fraction of unused segments that will be rolled over. Must be between 0 and 1.
	RolloverFraction *float64 `json:"rollover_fraction,omitempty"`
	// If multiple commits are applicable, the one with the lower priority will apply first.
	Priority *float64 `json:"priority,omitempty"`
	// Which products the commit applies to. If both applicable_product_ids and applicable_product_tags are not provided, the commit applies to all products.
	ApplicableProductIds []string `json:"applicable_product_ids,omitempty"`
	// Which tags the commit applies to. If both applicable_product_ids and applicable_product_tags are not provided, the commit applies to all products.
	ApplicableProductTags []string `json:"applicable_product_tags,omitempty"`
	// This field's availability is dependent on your client's configuration.
	NetsuiteSalesOrderID *string           `json:"netsuite_sales_order_id,omitempty"`
	CustomFields         map[string]string `json:"custom_fields,omitempty"`
}

func (o *AmendContractCommits) GetType() AmendContractType {
	if o == nil {
		return AmendContractType("")
	}
	return o.Type
}

func (o *AmendContractCommits) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *AmendContractCommits) GetProductID() string {
	if o == nil {
		return ""
	}
	return o.ProductID
}

func (o *AmendContractCommits) GetAccessSchedule() *AmendContractAccessSchedule {
	if o == nil {
		return nil
	}
	return o.AccessSchedule
}

func (o *AmendContractCommits) GetInvoiceSchedule() *AmendContractInvoiceSchedule {
	if o == nil {
		return nil
	}
	return o.InvoiceSchedule
}

func (o *AmendContractCommits) GetAmount() *float64 {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *AmendContractCommits) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *AmendContractCommits) GetRolloverFraction() *float64 {
	if o == nil {
		return nil
	}
	return o.RolloverFraction
}

func (o *AmendContractCommits) GetPriority() *float64 {
	if o == nil {
		return nil
	}
	return o.Priority
}

func (o *AmendContractCommits) GetApplicableProductIds() []string {
	if o == nil {
		return nil
	}
	return o.ApplicableProductIds
}

func (o *AmendContractCommits) GetApplicableProductTags() []string {
	if o == nil {
		return nil
	}
	return o.ApplicableProductTags
}

func (o *AmendContractCommits) GetNetsuiteSalesOrderID() *string {
	if o == nil {
		return nil
	}
	return o.NetsuiteSalesOrderID
}

func (o *AmendContractCommits) GetCustomFields() map[string]string {
	if o == nil {
		return nil
	}
	return o.CustomFields
}

type AmendContractContractsRequestScheduleItems struct {
	Amount float64 `json:"amount"`
	// RFC 3339 timestamp (inclusive)
	StartingAt time.Time `json:"starting_at"`
	// RFC 3339 timestamp (exclusive)
	EndingBefore time.Time `json:"ending_before"`
}

func (a AmendContractContractsRequestScheduleItems) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AmendContractContractsRequestScheduleItems) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *AmendContractContractsRequestScheduleItems) GetAmount() float64 {
	if o == nil {
		return 0.0
	}
	return o.Amount
}

func (o *AmendContractContractsRequestScheduleItems) GetStartingAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.StartingAt
}

func (o *AmendContractContractsRequestScheduleItems) GetEndingBefore() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.EndingBefore
}

// AmendContractContractsAccessSchedule - Schedule for distributing the credit to the customer.
type AmendContractContractsAccessSchedule struct {
	CreditTypeID  *string                                      `json:"credit_type_id,omitempty"`
	ScheduleItems []AmendContractContractsRequestScheduleItems `json:"schedule_items"`
}

func (o *AmendContractContractsAccessSchedule) GetCreditTypeID() *string {
	if o == nil {
		return nil
	}
	return o.CreditTypeID
}

func (o *AmendContractContractsAccessSchedule) GetScheduleItems() []AmendContractContractsRequestScheduleItems {
	if o == nil {
		return []AmendContractContractsRequestScheduleItems{}
	}
	return o.ScheduleItems
}

type AmendContractCredits struct {
	// displayed on invoices
	Name      *string `json:"name,omitempty"`
	ProductID string  `json:"product_id"`
	// Schedule for distributing the credit to the customer.
	AccessSchedule AmendContractContractsAccessSchedule `json:"access_schedule"`
	// Used only in UI/API. It is not exposed to end customers.
	Description *string `json:"description,omitempty"`
	// Which products the credit applies to. If both applicable_product_ids and applicable_product_tags are not provided, the credit applies to all products.
	ApplicableProductIds []string `json:"applicable_product_ids,omitempty"`
	// Which tags the credit applies to. If both applicable_product_ids and applicable_product_tags are not provided, the credit applies to all products.
	ApplicableProductTags []string `json:"applicable_product_tags,omitempty"`
	// This field's availability is dependent on your client's configuration.
	NetsuiteSalesOrderID *string `json:"netsuite_sales_order_id,omitempty"`
	// If multiple credits are applicable, the one with the lower priority will apply first.
	Priority     *float64          `json:"priority,omitempty"`
	CustomFields map[string]string `json:"custom_fields,omitempty"`
}

func (o *AmendContractCredits) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *AmendContractCredits) GetProductID() string {
	if o == nil {
		return ""
	}
	return o.ProductID
}

func (o *AmendContractCredits) GetAccessSchedule() AmendContractContractsAccessSchedule {
	if o == nil {
		return AmendContractContractsAccessSchedule{}
	}
	return o.AccessSchedule
}

func (o *AmendContractCredits) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *AmendContractCredits) GetApplicableProductIds() []string {
	if o == nil {
		return nil
	}
	return o.ApplicableProductIds
}

func (o *AmendContractCredits) GetApplicableProductTags() []string {
	if o == nil {
		return nil
	}
	return o.ApplicableProductTags
}

func (o *AmendContractCredits) GetNetsuiteSalesOrderID() *string {
	if o == nil {
		return nil
	}
	return o.NetsuiteSalesOrderID
}

func (o *AmendContractCredits) GetPriority() *float64 {
	if o == nil {
		return nil
	}
	return o.Priority
}

func (o *AmendContractCredits) GetCustomFields() map[string]string {
	if o == nil {
		return nil
	}
	return o.CustomFields
}

// AmendContractContractsType - Overwrites are prioritized over multipliers and tiered overrides.
type AmendContractContractsType string

const (
	AmendContractContractsTypeOverwriteUpper  AmendContractContractsType = "OVERWRITE"
	AmendContractContractsTypeOverwriteLower  AmendContractContractsType = "overwrite"
	AmendContractContractsTypeMultiplierUpper AmendContractContractsType = "MULTIPLIER"
	AmendContractContractsTypeMultiplierLower AmendContractContractsType = "multiplier"
	AmendContractContractsTypeTieredUpper     AmendContractContractsType = "TIERED"
	AmendContractContractsTypeTieredLower     AmendContractContractsType = "tiered"
)

func (e AmendContractContractsType) ToPointer() *AmendContractContractsType {
	return &e
}
func (e *AmendContractContractsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "OVERWRITE":
		fallthrough
	case "overwrite":
		fallthrough
	case "MULTIPLIER":
		fallthrough
	case "multiplier":
		fallthrough
	case "TIERED":
		fallthrough
	case "tiered":
		*e = AmendContractContractsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AmendContractContractsType: %v", v)
	}
}

type AmendContractRateType string

const (
	AmendContractRateTypeFlatUpper         AmendContractRateType = "FLAT"
	AmendContractRateTypeFlatLower         AmendContractRateType = "flat"
	AmendContractRateTypePercentageUpper   AmendContractRateType = "PERCENTAGE"
	AmendContractRateTypePercentageLower   AmendContractRateType = "percentage"
	AmendContractRateTypeSubscriptionUpper AmendContractRateType = "SUBSCRIPTION"
	AmendContractRateTypeSubscriptionLower AmendContractRateType = "subscription"
	AmendContractRateTypeTieredUpper       AmendContractRateType = "TIERED"
	AmendContractRateTypeTieredLower       AmendContractRateType = "tiered"
	AmendContractRateTypeCustomUpper       AmendContractRateType = "CUSTOM"
	AmendContractRateTypeCustomLower       AmendContractRateType = "custom"
)

func (e AmendContractRateType) ToPointer() *AmendContractRateType {
	return &e
}
func (e *AmendContractRateType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "FLAT":
		fallthrough
	case "flat":
		fallthrough
	case "PERCENTAGE":
		fallthrough
	case "percentage":
		fallthrough
	case "SUBSCRIPTION":
		fallthrough
	case "subscription":
		fallthrough
	case "TIERED":
		fallthrough
	case "tiered":
		fallthrough
	case "CUSTOM":
		fallthrough
	case "custom":
		*e = AmendContractRateType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AmendContractRateType: %v", v)
	}
}

type AmendContractTiers struct {
	Size  *float64 `json:"size,omitempty"`
	Price float64  `json:"price"`
}

func (o *AmendContractTiers) GetSize() *float64 {
	if o == nil {
		return nil
	}
	return o.Size
}

func (o *AmendContractTiers) GetPrice() float64 {
	if o == nil {
		return 0.0
	}
	return o.Price
}

// AmendContractOverwriteRate - Required for OVERWRITE type.
type AmendContractOverwriteRate struct {
	RateType AmendContractRateType `json:"rate_type"`
	// Default price. For FLAT rate_type, this must be >=0. For PERCENTAGE rate_type, this is a decimal fraction, e.g. use 0.1 for 10%; this must be >=0 and <=1.
	Price *float64 `json:"price,omitempty"`
	// Default quantity. For SUBSCRIPTION rate_type, this must be >=0.
	Quantity *float64 `json:"quantity,omitempty"`
	// Default proration configuration. Only valid for SUBSCRIPTION rate_type.
	IsProrated *bool `json:"is_prorated,omitempty"`
	// Only set for TIERED rate_type.
	Tiers []AmendContractTiers `json:"tiers,omitempty"`
	// Only set for CUSTOM rate_type. This field is interpreted by custom rate processors.
	CustomRate   map[string]any `json:"custom_rate,omitempty"`
	CreditTypeID *string        `json:"credit_type_id,omitempty"`
}

func (o *AmendContractOverwriteRate) GetRateType() AmendContractRateType {
	if o == nil {
		return AmendContractRateType("")
	}
	return o.RateType
}

func (o *AmendContractOverwriteRate) GetPrice() *float64 {
	if o == nil {
		return nil
	}
	return o.Price
}

func (o *AmendContractOverwriteRate) GetQuantity() *float64 {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *AmendContractOverwriteRate) GetIsProrated() *bool {
	if o == nil {
		return nil
	}
	return o.IsProrated
}

func (o *AmendContractOverwriteRate) GetTiers() []AmendContractTiers {
	if o == nil {
		return nil
	}
	return o.Tiers
}

func (o *AmendContractOverwriteRate) GetCustomRate() map[string]any {
	if o == nil {
		return nil
	}
	return o.CustomRate
}

func (o *AmendContractOverwriteRate) GetCreditTypeID() *string {
	if o == nil {
		return nil
	}
	return o.CreditTypeID
}

type AmendContractOverrideSpecifiers struct {
	// If provided, the override will only apply to the product with the specified ID.
	ProductID *string `json:"product_id,omitempty"`
	// If provided, the override will only apply to products with all the specified tags.
	ProductTags []string `json:"product_tags,omitempty"`
	// A map of pricing group names to values. The override will only apply to products with the specified pricing group values.
	PricingGroupValues map[string]string `json:"pricing_group_values,omitempty"`
	// A map of group names to values. The override will only apply to line items with the specified presentation group values. Can only be used for multiplier overrides.
	PresentationGroupValues map[string]string `json:"presentation_group_values,omitempty"`
}

func (o *AmendContractOverrideSpecifiers) GetProductID() *string {
	if o == nil {
		return nil
	}
	return o.ProductID
}

func (o *AmendContractOverrideSpecifiers) GetProductTags() []string {
	if o == nil {
		return nil
	}
	return o.ProductTags
}

func (o *AmendContractOverrideSpecifiers) GetPricingGroupValues() map[string]string {
	if o == nil {
		return nil
	}
	return o.PricingGroupValues
}

func (o *AmendContractOverrideSpecifiers) GetPresentationGroupValues() map[string]string {
	if o == nil {
		return nil
	}
	return o.PresentationGroupValues
}

type AmendContractContractsTiers struct {
	Size       *float64 `json:"size,omitempty"`
	Multiplier float64  `json:"multiplier"`
}

func (o *AmendContractContractsTiers) GetSize() *float64 {
	if o == nil {
		return nil
	}
	return o.Size
}

func (o *AmendContractContractsTiers) GetMultiplier() float64 {
	if o == nil {
		return 0.0
	}
	return o.Multiplier
}

type AmendContractOverrides struct {
	// RFC 3339 timestamp indicating when the override will start applying (inclusive)
	StartingAt time.Time `json:"starting_at"`
	// RFC 3339 timestamp indicating when the override will stop applying (exclusive)
	EndingBefore *time.Time `json:"ending_before,omitempty"`
	Entitled     *bool      `json:"entitled,omitempty"`
	// Overwrites are prioritized over multipliers and tiered overrides.
	Type *AmendContractContractsType `json:"type,omitempty"`
	// Required for MULTIPLIER type. Must be >=0.
	Multiplier *float64 `json:"multiplier,omitempty"`
	// Required for EXPLICIT multiplier prioritization scheme and all TIERED overrides. Under EXPLICIT prioritization, overwrites are prioritized first, and then tiered and multiplier overrides are prioritized by their priority value (lowest first). Must be > 0.
	Priority *float64 `json:"priority,omitempty"`
	// Required for OVERWRITE type.
	OverwriteRate *AmendContractOverwriteRate `json:"overwrite_rate,omitempty"`
	// ID of the product whose rate is being overridden
	ProductID *string `json:"product_id,omitempty"`
	// tags identifying products whose rates are being overridden
	ApplicableProductTags []string `json:"applicable_product_tags,omitempty"`
	// Cannot be used in conjunction with product_id or applicable_product_tags. If provided, the override will apply to all products with the specified specifiers.
	OverrideSpecifiers []AmendContractOverrideSpecifiers `json:"override_specifiers,omitempty"`
	// Required for TIERED type. Must have at least one tier.
	Tiers []AmendContractContractsTiers `json:"tiers,omitempty"`
}

func (a AmendContractOverrides) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AmendContractOverrides) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *AmendContractOverrides) GetStartingAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.StartingAt
}

func (o *AmendContractOverrides) GetEndingBefore() *time.Time {
	if o == nil {
		return nil
	}
	return o.EndingBefore
}

func (o *AmendContractOverrides) GetEntitled() *bool {
	if o == nil {
		return nil
	}
	return o.Entitled
}

func (o *AmendContractOverrides) GetType() *AmendContractContractsType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *AmendContractOverrides) GetMultiplier() *float64 {
	if o == nil {
		return nil
	}
	return o.Multiplier
}

func (o *AmendContractOverrides) GetPriority() *float64 {
	if o == nil {
		return nil
	}
	return o.Priority
}

func (o *AmendContractOverrides) GetOverwriteRate() *AmendContractOverwriteRate {
	if o == nil {
		return nil
	}
	return o.OverwriteRate
}

func (o *AmendContractOverrides) GetProductID() *string {
	if o == nil {
		return nil
	}
	return o.ProductID
}

func (o *AmendContractOverrides) GetApplicableProductTags() []string {
	if o == nil {
		return nil
	}
	return o.ApplicableProductTags
}

func (o *AmendContractOverrides) GetOverrideSpecifiers() []AmendContractOverrideSpecifiers {
	if o == nil {
		return nil
	}
	return o.OverrideSpecifiers
}

func (o *AmendContractOverrides) GetTiers() []AmendContractContractsTiers {
	if o == nil {
		return nil
	}
	return o.Tiers
}

type AmendContractContractsRequestRequestBodyScheduleItems struct {
	// Unit price for the charge. Will be multiplied by quantity to determine the amount and must be specified with quantity. If specified amount cannot be provided.
	UnitPrice *float64 `json:"unit_price,omitempty"`
	// Quantity for the charge. Will be multiplied by unit_price to determine the amount and must be specified with unit_price. If specified amount cannot be provided.
	Quantity *float64 `json:"quantity,omitempty"`
	// Amount for the charge. Can be provided instead of unit_price and quantity. If amount is sent, the unit_price is assumed to be the amount and quantity is inferred to be 1.
	Amount *float64 `json:"amount,omitempty"`
	// timestamp of the scheduled event
	Timestamp time.Time `json:"timestamp"`
}

func (a AmendContractContractsRequestRequestBodyScheduleItems) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AmendContractContractsRequestRequestBodyScheduleItems) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *AmendContractContractsRequestRequestBodyScheduleItems) GetUnitPrice() *float64 {
	if o == nil {
		return nil
	}
	return o.UnitPrice
}

func (o *AmendContractContractsRequestRequestBodyScheduleItems) GetQuantity() *float64 {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *AmendContractContractsRequestRequestBodyScheduleItems) GetAmount() *float64 {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *AmendContractContractsRequestRequestBodyScheduleItems) GetTimestamp() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.Timestamp
}

type AmendContractContractsFrequency string

const (
	AmendContractContractsFrequencyMonthlyUpper    AmendContractContractsFrequency = "MONTHLY"
	AmendContractContractsFrequencyMonthlyLower    AmendContractContractsFrequency = "monthly"
	AmendContractContractsFrequencyQuarterlyUpper  AmendContractContractsFrequency = "QUARTERLY"
	AmendContractContractsFrequencyQuarterlyLower  AmendContractContractsFrequency = "quarterly"
	AmendContractContractsFrequencySemiAnnualUpper AmendContractContractsFrequency = "SEMI_ANNUAL"
	AmendContractContractsFrequencySemiAnnualLower AmendContractContractsFrequency = "semi_annual"
	AmendContractContractsFrequencyAnnualUpper     AmendContractContractsFrequency = "ANNUAL"
	AmendContractContractsFrequencyAnnualLower     AmendContractContractsFrequency = "annual"
)

func (e AmendContractContractsFrequency) ToPointer() *AmendContractContractsFrequency {
	return &e
}
func (e *AmendContractContractsFrequency) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MONTHLY":
		fallthrough
	case "monthly":
		fallthrough
	case "QUARTERLY":
		fallthrough
	case "quarterly":
		fallthrough
	case "SEMI_ANNUAL":
		fallthrough
	case "semi_annual":
		fallthrough
	case "ANNUAL":
		fallthrough
	case "annual":
		*e = AmendContractContractsFrequency(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AmendContractContractsFrequency: %v", v)
	}
}

type AmendContractContractsAmountDistribution string

const (
	AmendContractContractsAmountDistributionDividedUpper        AmendContractContractsAmountDistribution = "DIVIDED"
	AmendContractContractsAmountDistributionDividedLower        AmendContractContractsAmountDistribution = "divided"
	AmendContractContractsAmountDistributionDividedRoundedUpper AmendContractContractsAmountDistribution = "DIVIDED_ROUNDED"
	AmendContractContractsAmountDistributionDividedRoundedLower AmendContractContractsAmountDistribution = "divided_rounded"
	AmendContractContractsAmountDistributionEachUpper           AmendContractContractsAmountDistribution = "EACH"
	AmendContractContractsAmountDistributionEachLower           AmendContractContractsAmountDistribution = "each"
)

func (e AmendContractContractsAmountDistribution) ToPointer() *AmendContractContractsAmountDistribution {
	return &e
}
func (e *AmendContractContractsAmountDistribution) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DIVIDED":
		fallthrough
	case "divided":
		fallthrough
	case "DIVIDED_ROUNDED":
		fallthrough
	case "divided_rounded":
		fallthrough
	case "EACH":
		fallthrough
	case "each":
		*e = AmendContractContractsAmountDistribution(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AmendContractContractsAmountDistribution: %v", v)
	}
}

// AmendContractContractsRecurringSchedule - Enter the unit price and quantity for the charge or instead only send the amount. If amount is sent, the unit price is assumed to be the amount and quantity is inferred to be 1.
type AmendContractContractsRecurringSchedule struct {
	// RFC 3339 timestamp (inclusive).
	StartingAt time.Time `json:"starting_at"`
	// RFC 3339 timestamp (exclusive).
	EndingBefore time.Time                       `json:"ending_before"`
	Frequency    AmendContractContractsFrequency `json:"frequency"`
	// Unit price for the charge. Will be multiplied by quantity to determine the amount and must be specified with quantity. If specified amount cannot be provided.
	UnitPrice *float64 `json:"unit_price,omitempty"`
	// Quantity for the charge. Will be multiplied by unit_price to determine the amount and must be specified with unit_price. If specified amount cannot be provided.
	Quantity *float64 `json:"quantity,omitempty"`
	// Amount for the charge. Can be provided instead of unit_price and quantity. If amount is sent, the unit_price is assumed to be the amount and quantity is inferred to be 1.
	Amount             *float64                                 `json:"amount,omitempty"`
	AmountDistribution AmendContractContractsAmountDistribution `json:"amount_distribution"`
}

func (a AmendContractContractsRecurringSchedule) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AmendContractContractsRecurringSchedule) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *AmendContractContractsRecurringSchedule) GetStartingAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.StartingAt
}

func (o *AmendContractContractsRecurringSchedule) GetEndingBefore() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.EndingBefore
}

func (o *AmendContractContractsRecurringSchedule) GetFrequency() AmendContractContractsFrequency {
	if o == nil {
		return AmendContractContractsFrequency("")
	}
	return o.Frequency
}

func (o *AmendContractContractsRecurringSchedule) GetUnitPrice() *float64 {
	if o == nil {
		return nil
	}
	return o.UnitPrice
}

func (o *AmendContractContractsRecurringSchedule) GetQuantity() *float64 {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *AmendContractContractsRecurringSchedule) GetAmount() *float64 {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *AmendContractContractsRecurringSchedule) GetAmountDistribution() AmendContractContractsAmountDistribution {
	if o == nil {
		return AmendContractContractsAmountDistribution("")
	}
	return o.AmountDistribution
}

// AmendContractSchedule - Must provide either schedule_items or recurring_schedule.
type AmendContractSchedule struct {
	// Defaults to USD if not passed. Only USD is supported at this time.
	CreditTypeID *string `json:"credit_type_id,omitempty"`
	// Either provide amount or provide both unit_price and quantity.
	ScheduleItems []AmendContractContractsRequestRequestBodyScheduleItems `json:"schedule_items,omitempty"`
	// Enter the unit price and quantity for the charge or instead only send the amount. If amount is sent, the unit price is assumed to be the amount and quantity is inferred to be 1.
	RecurringSchedule *AmendContractContractsRecurringSchedule `json:"recurring_schedule,omitempty"`
}

func (o *AmendContractSchedule) GetCreditTypeID() *string {
	if o == nil {
		return nil
	}
	return o.CreditTypeID
}

func (o *AmendContractSchedule) GetScheduleItems() []AmendContractContractsRequestRequestBodyScheduleItems {
	if o == nil {
		return nil
	}
	return o.ScheduleItems
}

func (o *AmendContractSchedule) GetRecurringSchedule() *AmendContractContractsRecurringSchedule {
	if o == nil {
		return nil
	}
	return o.RecurringSchedule
}

type AmendContractDiscounts struct {
	ProductID string `json:"product_id"`
	// displayed on invoices
	Name *string `json:"name,omitempty"`
	// Must provide either schedule_items or recurring_schedule.
	Schedule AmendContractSchedule `json:"schedule"`
	// This field's availability is dependent on your client's configuration.
	NetsuiteSalesOrderID *string `json:"netsuite_sales_order_id,omitempty"`
}

func (o *AmendContractDiscounts) GetProductID() string {
	if o == nil {
		return ""
	}
	return o.ProductID
}

func (o *AmendContractDiscounts) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *AmendContractDiscounts) GetSchedule() AmendContractSchedule {
	if o == nil {
		return AmendContractSchedule{}
	}
	return o.Schedule
}

func (o *AmendContractDiscounts) GetNetsuiteSalesOrderID() *string {
	if o == nil {
		return nil
	}
	return o.NetsuiteSalesOrderID
}

type AmendContractProfessionalServices struct {
	Description *string `json:"description,omitempty"`
	ProductID   string  `json:"product_id"`
	// This field's availability is dependent on your client's configuration.
	NetsuiteSalesOrderID *string `json:"netsuite_sales_order_id,omitempty"`
	// Unit price for the charge. Will be multiplied by quantity to determine the amount and must be specified.
	UnitPrice float64 `json:"unit_price"`
	// Quantity for the charge. Will be multiplied by unit_price to determine the amount.
	Quantity float64 `json:"quantity"`
	// Maximum amount for the term.
	MaxAmount    float64           `json:"max_amount"`
	CustomFields map[string]string `json:"custom_fields,omitempty"`
}

func (o *AmendContractProfessionalServices) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *AmendContractProfessionalServices) GetProductID() string {
	if o == nil {
		return ""
	}
	return o.ProductID
}

func (o *AmendContractProfessionalServices) GetNetsuiteSalesOrderID() *string {
	if o == nil {
		return nil
	}
	return o.NetsuiteSalesOrderID
}

func (o *AmendContractProfessionalServices) GetUnitPrice() float64 {
	if o == nil {
		return 0.0
	}
	return o.UnitPrice
}

func (o *AmendContractProfessionalServices) GetQuantity() float64 {
	if o == nil {
		return 0.0
	}
	return o.Quantity
}

func (o *AmendContractProfessionalServices) GetMaxAmount() float64 {
	if o == nil {
		return 0.0
	}
	return o.MaxAmount
}

func (o *AmendContractProfessionalServices) GetCustomFields() map[string]string {
	if o == nil {
		return nil
	}
	return o.CustomFields
}

type AmendContractResellerType string

const (
	AmendContractResellerTypeAws           AmendContractResellerType = "AWS"
	AmendContractResellerTypeAwsProService AmendContractResellerType = "AWS_PRO_SERVICE"
	AmendContractResellerTypeGcp           AmendContractResellerType = "GCP"
	AmendContractResellerTypeGcpProService AmendContractResellerType = "GCP_PRO_SERVICE"
)

func (e AmendContractResellerType) ToPointer() *AmendContractResellerType {
	return &e
}
func (e *AmendContractResellerType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "AWS":
		fallthrough
	case "AWS_PRO_SERVICE":
		fallthrough
	case "GCP":
		fallthrough
	case "GCP_PRO_SERVICE":
		*e = AmendContractResellerType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AmendContractResellerType: %v", v)
	}
}

type AmendContractAwsOptions struct {
	AwsAccountNumber    *string `json:"aws_account_number,omitempty"`
	AwsPayerReferenceID *string `json:"aws_payer_reference_id,omitempty"`
	AwsOfferID          *string `json:"aws_offer_id,omitempty"`
}

func (o *AmendContractAwsOptions) GetAwsAccountNumber() *string {
	if o == nil {
		return nil
	}
	return o.AwsAccountNumber
}

func (o *AmendContractAwsOptions) GetAwsPayerReferenceID() *string {
	if o == nil {
		return nil
	}
	return o.AwsPayerReferenceID
}

func (o *AmendContractAwsOptions) GetAwsOfferID() *string {
	if o == nil {
		return nil
	}
	return o.AwsOfferID
}

type AmendContractGcpOptions struct {
	GcpAccountID *string `json:"gcp_account_id,omitempty"`
	GcpOfferID   *string `json:"gcp_offer_id,omitempty"`
}

func (o *AmendContractGcpOptions) GetGcpAccountID() *string {
	if o == nil {
		return nil
	}
	return o.GcpAccountID
}

func (o *AmendContractGcpOptions) GetGcpOfferID() *string {
	if o == nil {
		return nil
	}
	return o.GcpOfferID
}

type AmendContractResellerRoyalties struct {
	ResellerType       AmendContractResellerType `json:"reseller_type"`
	Fraction           *float64                  `json:"fraction,omitempty"`
	NetsuiteResellerID *string                   `json:"netsuite_reseller_id,omitempty"`
	// Must provide at least one of applicable_product_ids or applicable_product_tags.
	ApplicableProductIds []string `json:"applicable_product_ids,omitempty"`
	// Must provide at least one of applicable_product_ids or applicable_product_tags.
	ApplicableProductTags []string   `json:"applicable_product_tags,omitempty"`
	StartingAt            *time.Time `json:"starting_at,omitempty"`
	// Use null to indicate that the existing end timestamp should be removed.
	EndingBefore          *time.Time               `json:"ending_before,omitempty"`
	ResellerContractValue *float64                 `json:"reseller_contract_value,omitempty"`
	AwsOptions            *AmendContractAwsOptions `json:"aws_options,omitempty"`
	GcpOptions            *AmendContractGcpOptions `json:"gcp_options,omitempty"`
}

func (a AmendContractResellerRoyalties) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AmendContractResellerRoyalties) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *AmendContractResellerRoyalties) GetResellerType() AmendContractResellerType {
	if o == nil {
		return AmendContractResellerType("")
	}
	return o.ResellerType
}

func (o *AmendContractResellerRoyalties) GetFraction() *float64 {
	if o == nil {
		return nil
	}
	return o.Fraction
}

func (o *AmendContractResellerRoyalties) GetNetsuiteResellerID() *string {
	if o == nil {
		return nil
	}
	return o.NetsuiteResellerID
}

func (o *AmendContractResellerRoyalties) GetApplicableProductIds() []string {
	if o == nil {
		return nil
	}
	return o.ApplicableProductIds
}

func (o *AmendContractResellerRoyalties) GetApplicableProductTags() []string {
	if o == nil {
		return nil
	}
	return o.ApplicableProductTags
}

func (o *AmendContractResellerRoyalties) GetStartingAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.StartingAt
}

func (o *AmendContractResellerRoyalties) GetEndingBefore() *time.Time {
	if o == nil {
		return nil
	}
	return o.EndingBefore
}

func (o *AmendContractResellerRoyalties) GetResellerContractValue() *float64 {
	if o == nil {
		return nil
	}
	return o.ResellerContractValue
}

func (o *AmendContractResellerRoyalties) GetAwsOptions() *AmendContractAwsOptions {
	if o == nil {
		return nil
	}
	return o.AwsOptions
}

func (o *AmendContractResellerRoyalties) GetGcpOptions() *AmendContractGcpOptions {
	if o == nil {
		return nil
	}
	return o.GcpOptions
}

type AmendContractContractsRequestRequestBodyScheduledChargesScheduleItems struct {
	// Unit price for the charge. Will be multiplied by quantity to determine the amount and must be specified with quantity. If specified amount cannot be provided.
	UnitPrice *float64 `json:"unit_price,omitempty"`
	// Quantity for the charge. Will be multiplied by unit_price to determine the amount and must be specified with unit_price. If specified amount cannot be provided.
	Quantity *float64 `json:"quantity,omitempty"`
	// Amount for the charge. Can be provided instead of unit_price and quantity. If amount is sent, the unit_price is assumed to be the amount and quantity is inferred to be 1.
	Amount *float64 `json:"amount,omitempty"`
	// timestamp of the scheduled event
	Timestamp time.Time `json:"timestamp"`
}

func (a AmendContractContractsRequestRequestBodyScheduledChargesScheduleItems) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AmendContractContractsRequestRequestBodyScheduledChargesScheduleItems) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *AmendContractContractsRequestRequestBodyScheduledChargesScheduleItems) GetUnitPrice() *float64 {
	if o == nil {
		return nil
	}
	return o.UnitPrice
}

func (o *AmendContractContractsRequestRequestBodyScheduledChargesScheduleItems) GetQuantity() *float64 {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *AmendContractContractsRequestRequestBodyScheduledChargesScheduleItems) GetAmount() *float64 {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *AmendContractContractsRequestRequestBodyScheduledChargesScheduleItems) GetTimestamp() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.Timestamp
}

type AmendContractContractsRequestFrequency string

const (
	AmendContractContractsRequestFrequencyMonthlyUpper    AmendContractContractsRequestFrequency = "MONTHLY"
	AmendContractContractsRequestFrequencyMonthlyLower    AmendContractContractsRequestFrequency = "monthly"
	AmendContractContractsRequestFrequencyQuarterlyUpper  AmendContractContractsRequestFrequency = "QUARTERLY"
	AmendContractContractsRequestFrequencyQuarterlyLower  AmendContractContractsRequestFrequency = "quarterly"
	AmendContractContractsRequestFrequencySemiAnnualUpper AmendContractContractsRequestFrequency = "SEMI_ANNUAL"
	AmendContractContractsRequestFrequencySemiAnnualLower AmendContractContractsRequestFrequency = "semi_annual"
	AmendContractContractsRequestFrequencyAnnualUpper     AmendContractContractsRequestFrequency = "ANNUAL"
	AmendContractContractsRequestFrequencyAnnualLower     AmendContractContractsRequestFrequency = "annual"
)

func (e AmendContractContractsRequestFrequency) ToPointer() *AmendContractContractsRequestFrequency {
	return &e
}
func (e *AmendContractContractsRequestFrequency) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MONTHLY":
		fallthrough
	case "monthly":
		fallthrough
	case "QUARTERLY":
		fallthrough
	case "quarterly":
		fallthrough
	case "SEMI_ANNUAL":
		fallthrough
	case "semi_annual":
		fallthrough
	case "ANNUAL":
		fallthrough
	case "annual":
		*e = AmendContractContractsRequestFrequency(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AmendContractContractsRequestFrequency: %v", v)
	}
}

type AmendContractContractsRequestAmountDistribution string

const (
	AmendContractContractsRequestAmountDistributionDividedUpper        AmendContractContractsRequestAmountDistribution = "DIVIDED"
	AmendContractContractsRequestAmountDistributionDividedLower        AmendContractContractsRequestAmountDistribution = "divided"
	AmendContractContractsRequestAmountDistributionDividedRoundedUpper AmendContractContractsRequestAmountDistribution = "DIVIDED_ROUNDED"
	AmendContractContractsRequestAmountDistributionDividedRoundedLower AmendContractContractsRequestAmountDistribution = "divided_rounded"
	AmendContractContractsRequestAmountDistributionEachUpper           AmendContractContractsRequestAmountDistribution = "EACH"
	AmendContractContractsRequestAmountDistributionEachLower           AmendContractContractsRequestAmountDistribution = "each"
)

func (e AmendContractContractsRequestAmountDistribution) ToPointer() *AmendContractContractsRequestAmountDistribution {
	return &e
}
func (e *AmendContractContractsRequestAmountDistribution) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DIVIDED":
		fallthrough
	case "divided":
		fallthrough
	case "DIVIDED_ROUNDED":
		fallthrough
	case "divided_rounded":
		fallthrough
	case "EACH":
		fallthrough
	case "each":
		*e = AmendContractContractsRequestAmountDistribution(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AmendContractContractsRequestAmountDistribution: %v", v)
	}
}

// AmendContractContractsRequestRecurringSchedule - Enter the unit price and quantity for the charge or instead only send the amount. If amount is sent, the unit price is assumed to be the amount and quantity is inferred to be 1.
type AmendContractContractsRequestRecurringSchedule struct {
	// RFC 3339 timestamp (inclusive).
	StartingAt time.Time `json:"starting_at"`
	// RFC 3339 timestamp (exclusive).
	EndingBefore time.Time                              `json:"ending_before"`
	Frequency    AmendContractContractsRequestFrequency `json:"frequency"`
	// Unit price for the charge. Will be multiplied by quantity to determine the amount and must be specified with quantity. If specified amount cannot be provided.
	UnitPrice *float64 `json:"unit_price,omitempty"`
	// Quantity for the charge. Will be multiplied by unit_price to determine the amount and must be specified with unit_price. If specified amount cannot be provided.
	Quantity *float64 `json:"quantity,omitempty"`
	// Amount for the charge. Can be provided instead of unit_price and quantity. If amount is sent, the unit_price is assumed to be the amount and quantity is inferred to be 1.
	Amount             *float64                                        `json:"amount,omitempty"`
	AmountDistribution AmendContractContractsRequestAmountDistribution `json:"amount_distribution"`
}

func (a AmendContractContractsRequestRecurringSchedule) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AmendContractContractsRequestRecurringSchedule) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *AmendContractContractsRequestRecurringSchedule) GetStartingAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.StartingAt
}

func (o *AmendContractContractsRequestRecurringSchedule) GetEndingBefore() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.EndingBefore
}

func (o *AmendContractContractsRequestRecurringSchedule) GetFrequency() AmendContractContractsRequestFrequency {
	if o == nil {
		return AmendContractContractsRequestFrequency("")
	}
	return o.Frequency
}

func (o *AmendContractContractsRequestRecurringSchedule) GetUnitPrice() *float64 {
	if o == nil {
		return nil
	}
	return o.UnitPrice
}

func (o *AmendContractContractsRequestRecurringSchedule) GetQuantity() *float64 {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *AmendContractContractsRequestRecurringSchedule) GetAmount() *float64 {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *AmendContractContractsRequestRecurringSchedule) GetAmountDistribution() AmendContractContractsRequestAmountDistribution {
	if o == nil {
		return AmendContractContractsRequestAmountDistribution("")
	}
	return o.AmountDistribution
}

// AmendContractContractsSchedule - Must provide either schedule_items or recurring_schedule.
type AmendContractContractsSchedule struct {
	// Defaults to USD if not passed. Only USD is supported at this time.
	CreditTypeID *string `json:"credit_type_id,omitempty"`
	// Either provide amount or provide both unit_price and quantity.
	ScheduleItems []AmendContractContractsRequestRequestBodyScheduledChargesScheduleItems `json:"schedule_items,omitempty"`
	// Enter the unit price and quantity for the charge or instead only send the amount. If amount is sent, the unit price is assumed to be the amount and quantity is inferred to be 1.
	RecurringSchedule *AmendContractContractsRequestRecurringSchedule `json:"recurring_schedule,omitempty"`
}

func (o *AmendContractContractsSchedule) GetCreditTypeID() *string {
	if o == nil {
		return nil
	}
	return o.CreditTypeID
}

func (o *AmendContractContractsSchedule) GetScheduleItems() []AmendContractContractsRequestRequestBodyScheduledChargesScheduleItems {
	if o == nil {
		return nil
	}
	return o.ScheduleItems
}

func (o *AmendContractContractsSchedule) GetRecurringSchedule() *AmendContractContractsRequestRecurringSchedule {
	if o == nil {
		return nil
	}
	return o.RecurringSchedule
}

type AmendContractScheduledCharges struct {
	ProductID string `json:"product_id"`
	// displayed on invoices
	Name *string `json:"name,omitempty"`
	// Must provide either schedule_items or recurring_schedule.
	Schedule AmendContractContractsSchedule `json:"schedule"`
	// This field's availability is dependent on your client's configuration.
	NetsuiteSalesOrderID *string `json:"netsuite_sales_order_id,omitempty"`
}

func (o *AmendContractScheduledCharges) GetProductID() string {
	if o == nil {
		return ""
	}
	return o.ProductID
}

func (o *AmendContractScheduledCharges) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *AmendContractScheduledCharges) GetSchedule() AmendContractContractsSchedule {
	if o == nil {
		return AmendContractContractsSchedule{}
	}
	return o.Schedule
}

func (o *AmendContractScheduledCharges) GetNetsuiteSalesOrderID() *string {
	if o == nil {
		return nil
	}
	return o.NetsuiteSalesOrderID
}

// AmendContractRequestBody - Amend a contract
type AmendContractRequestBody struct {
	// ID of the customer whose contract is to be amended
	CustomerID string `json:"customer_id"`
	// ID of the contract to amend
	ContractID string `json:"contract_id"`
	// This field's availability is dependent on your client's configuration.
	NetsuiteSalesOrderID *string `json:"netsuite_sales_order_id,omitempty"`
	// This field's availability is dependent on your client's configuration.
	SalesforceOpportunityID *string `json:"salesforce_opportunity_id,omitempty"`
	// This field's availability is dependent on your client's configuration.
	TotalContractValue *float64 `json:"total_contract_value,omitempty"`
	// inclusive start time for the amendment
	StartingAt time.Time                `json:"starting_at"`
	Commits    []AmendContractCommits   `json:"commits,omitempty"`
	Credits    []AmendContractCredits   `json:"credits,omitempty"`
	Overrides  []AmendContractOverrides `json:"overrides,omitempty"`
	// This field's availability is dependent on your client's configuration.
	Discounts []AmendContractDiscounts `json:"discounts,omitempty"`
	// This field's availability is dependent on your client's configuration.
	ProfessionalServices []AmendContractProfessionalServices `json:"professional_services,omitempty"`
	// This field's availability is dependent on your client's configuration.
	ResellerRoyalties []AmendContractResellerRoyalties `json:"reseller_royalties,omitempty"`
	ScheduledCharges  []AmendContractScheduledCharges  `json:"scheduled_charges,omitempty"`
	CustomFields      map[string]string                `json:"custom_fields,omitempty"`
}

func (a AmendContractRequestBody) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AmendContractRequestBody) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *AmendContractRequestBody) GetCustomerID() string {
	if o == nil {
		return ""
	}
	return o.CustomerID
}

func (o *AmendContractRequestBody) GetContractID() string {
	if o == nil {
		return ""
	}
	return o.ContractID
}

func (o *AmendContractRequestBody) GetNetsuiteSalesOrderID() *string {
	if o == nil {
		return nil
	}
	return o.NetsuiteSalesOrderID
}

func (o *AmendContractRequestBody) GetSalesforceOpportunityID() *string {
	if o == nil {
		return nil
	}
	return o.SalesforceOpportunityID
}

func (o *AmendContractRequestBody) GetTotalContractValue() *float64 {
	if o == nil {
		return nil
	}
	return o.TotalContractValue
}

func (o *AmendContractRequestBody) GetStartingAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.StartingAt
}

func (o *AmendContractRequestBody) GetCommits() []AmendContractCommits {
	if o == nil {
		return nil
	}
	return o.Commits
}

func (o *AmendContractRequestBody) GetCredits() []AmendContractCredits {
	if o == nil {
		return nil
	}
	return o.Credits
}

func (o *AmendContractRequestBody) GetOverrides() []AmendContractOverrides {
	if o == nil {
		return nil
	}
	return o.Overrides
}

func (o *AmendContractRequestBody) GetDiscounts() []AmendContractDiscounts {
	if o == nil {
		return nil
	}
	return o.Discounts
}

func (o *AmendContractRequestBody) GetProfessionalServices() []AmendContractProfessionalServices {
	if o == nil {
		return nil
	}
	return o.ProfessionalServices
}

func (o *AmendContractRequestBody) GetResellerRoyalties() []AmendContractResellerRoyalties {
	if o == nil {
		return nil
	}
	return o.ResellerRoyalties
}

func (o *AmendContractRequestBody) GetScheduledCharges() []AmendContractScheduledCharges {
	if o == nil {
		return nil
	}
	return o.ScheduledCharges
}

func (o *AmendContractRequestBody) GetCustomFields() map[string]string {
	if o == nil {
		return nil
	}
	return o.CustomFields
}

type AmendContractData struct {
	ID string `json:"id"`
}

func (o *AmendContractData) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

// AmendContractResponseBody - Success
type AmendContractResponseBody struct {
	Data AmendContractData `json:"data"`
}

func (o *AmendContractResponseBody) GetData() AmendContractData {
	if o == nil {
		return AmendContractData{}
	}
	return o.Data
}

type AmendContractResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// Success
	Object *AmendContractResponseBody
}

func (o *AmendContractResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *AmendContractResponse) GetObject() *AmendContractResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
